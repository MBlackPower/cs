<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=gb_2312-80">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>标准建模语言UML及其支持环境(四)</title>
</head>

<body bgcolor="#D9D9D9">

<p align="center"><font color="#FF0000" size="4">标准建模语言UML及其支持环境(四)<br>
</font></p>

<p align="center">北京航空航天大学软件工程研究所</p>

<p><br>
(接上期)<br>
前三期所述主要内容如下:<br>
一、标准建模语言UML概述<br>
二、标准建模语言UML的静态建模机制<br>
1. 用例图<br>
2. 类图、对象图和包</p>

<p align="center"><img src="../images/uml4-1.jpg" width="326"
height="282"></p>

<p align="left">3. 构件图和配置图<br>
构件图(Component diagram)和配置图(Deployment diagram)显示系统实现时的一些特性,包括源代码的静态结构和运行时刻的实现结构。构件图显示代码本身的结构,配置图显示系统运行时刻的结构。</p>

<p align="left"><br>
(1) 构件图
构件图显示软件构件之间的依赖关系。一般来说,软件构件就是一个实际文件,可以是源代码文件、二进制代码文件和可执行文件等。可以用来显示编译、链接或执行时构件之间的依赖关系。<br>
(2) 配置图
配置图描述系统硬件的物理拓扑结构以及在此结构上执行的软件。配置图可以显示计算结点的拓扑结构和通信路径、结点上运行的软件构件、软件构件包含的逻辑单元(对象、类)等。配置图常常用于帮助理解分布式系统。<br>
(3) 结点和连接　结点(Node)代表一个物理设备以及其上运行的软件系统,如一台Unix主机、一个PC终端、一台打印机、一个传感器等。如图1所示,&quot;客户端PC&quot;和&quot;保险后台服务器&quot;就是两个结点。结点表示为一个立方体,结点名放在左上角。<br>
结点之间的连线表示系统之间进行交互的通信路径,在UML中被称为连接(Connectio
n)。通信类型则放在连接旁边的&quot;《》&quot;之间,表示所用的通信协议或网络类型。<br>
(4) 构件和界面　在配置图中,构件代表可执行的物理代码模块,如一个可执行程序。逻辑上它可以与类图中的包或类对应。因此,配置图中显示运行时各个包或类在结点中的分布情况。如在图1中,&quot;保险后台服务器&quot;
结点中包含&quot;保险系统&quot;、&quot;保险对象数据库&quot;和&quot;保险系统配置&quot;3个构件。在面向对象方法中,类和构件等元素并不是所有的属性和操作都对外可见。它们对外提供了可见操作和属性,称之为类和构件的界面。界面可以表示为一头是小园圈的直线。图1中,&quot;保险系统&quot;构件提供了一个&quot;配置&quot;界面。配置图中还显示了构件之间的依赖关系,&quot;保险系统配置&quot;构件依赖于这个&quot;配置&quot;界面。<br>
(5) 对象(Object)　一个面向对象软件系统中可以运行很多对象。由于构件可以看作与包或类对应的物理代码模块,因此,构件中应包含一些运行的对象。配置图中的对象与对象图中的对象表示法一样。图1中,&quot;保险系统配置&quot;构件包含&quot;配置保险政策&quot;和&quot;配置用户&quot;两个对象。</p>

<p align="left"><br>
标准建模语言UML的静态建模机制是采用UML进行建模的基础。我们认为,熟练掌握基本概念、区分不同抽象层次以及在实践中灵活运用,是三条最值得注意的基本原则。</p>

<p align="left"><br>
三、标准建模语言UML的动态建模机制</p>

<p align="left"><br>
1. 消息</p>

<p align="left"><br>
在面向对象技术中,对象间的交互是通过对象间消息的传递来完成的。在UML的四个动态模型中均用到消息这个概念。通常,当一个对象调用另一个对象中的操作时,即完成了一次消息传递。当操作执行后,控制便返回到调用者。对象通过相互间的通信(消息传递)进行合作,并在其生命周期中根据通信的结果不断改变自身的状态。</p>

<p align="left"><br>
在UML中,消息的图形表示是用带有箭头的线段将消息的发送者和接收者联系起来,箭头的类型表示消息的类型,如图2所示。</p>

<p align="center"><br>
<img src="../images/uml4-2.jpg" width="196" height="154"></p>

<p align="left">　</p>

<p align="left">UML定义的消息类型有三种:</p>

<p align="left"><br>
简单消息(Simple Message)
表示简单的控制流。用于描述控制如何在对象间进行传递,而不考虑通信的细节。<br>
同步消息(Synchronous Message)
表示嵌套的控制流。操作的调用是一种典型的同步消息。调用者发出消息后必须等待消息返回,只有当处理消息的操作执行完毕后,调用者才可继续执行自己的操作。</p>

<p align="left">异步消息(Asynchronous Message)
表示异步控制流。当调用者发出消息后不用等待消息的返回即可继续执行自己的操作。异步消息主要用于描述实时系统中的并发行为。</p>

<p align="left"><br>
2. 状态图<br>
状态图(State Diagram)用来描述一个特定对象的所有可能状态及其引起状态转移的事件。大多数面向对象技术都用状态图表示单个对象在其生命周期中的行为。一个状态图包括一系列的状态以及状态之间的转移。</p>

<p align="left"><br>
(1) 状态　所有对象都具有状态,状态是对象执行了一系列活动的结果。当某个事件发生后,对象的状态将发生变化。状态图中定义的状态有:初态、终态、中间状态、复合状态。其中,初态是状态图的起始点,而终态则是状态图的终点。一个状态图只能有一个初态,而终态则可以有多个。</p>

<p align="left">中间状态包括两个区域:名字域和内部转移域,如图3所示。图中内部转移域是可选的,其中所列的动作将在对象处于该状态时执行,且该动作的执行并不改变对象的状态。</p>

<p align="center"><img src="../images/uml4-3.jpg" width="283"
height="162"></p>

<p align="left">　</p>

<p align="left">一个状态可以进一步地细化为多个子状态,我们将可以进一步细化的状态称作复合状态。子状态之间有&quot;或关系&quot;和&quot;与关系&quot;两种关系。或关系(如
图4)说明在某一时刻仅可到达一个子状态。例如,一个处于行驶状态的汽车,在&quot;行驶&quot;这个复合状态中有向前和向后两个不同的子状态,在某一时刻汽车要么向前,要么向后。与关系(
如图5)说明复合状态中在某一时刻可同时到达多个子状态(称为并发子状态)。具有并发子状态的状态图称为并发状态图。</p>

<p align="center"><img src="../images/uml4-4.jpg" width="330"
height="140"><br>
</p>

<p align="center"><img src="../images/uml4-5.jpg" width="313"
height="175"></p>

<p align="left">(2)
转移　状态图中状态之间带箭头的连线被称为转移。状态的变迁通常是由事件触发的,此时应在转移上标出触发转移的事件表达式。如果转移上未标明事件,则表示在源状态的内部活动执行完毕后自动触发转移。</p>

<p align="left"><br>
3. 顺序图</p>

<p align="left"><br>
顺序图(Sequence Diagram)用来描述对象之间动态的交互关系,着重体现对象间消息传递的时间顺序。顺序图存在两个轴:水平轴表示不同的对象,垂直轴表示时间。顺序图中的对象用一个带有垂直虚线的矩形框表示,并标有对象名和类名。垂直虚线是对象的生命线,用于表示在某段时间内对象是存在的。对象间的通信通过在对象的生命线间画消息来表示。消息的箭头指明消息的类型。</p>

<p align="left"><br>
顺序图中的消息可以是信号(Signal)、操作调用或类似于C++中的RPC(RemoteProce
dure Calls)和Java中的RMI(Remote Method Invocation)。当收到消息时,接收对象立即开始执行活动,即对象被激活了。通过在对象生命线上显示一个细长矩形框来表示激活。</p>

<p align="left"><br>
消息可以用消息名及参数来标识。消息也可带有顺序号,但较少使用。消息还可带有条件表达式,表示分支或决定是否发送消息。如果用于表示分支,则每个分支是相互排斥的,即在某一时刻仅可发送分支中的一个消息。</p>

<p align="left"><br>
在顺序图的左边可以有说明信息,用于说明消息发送的时刻、描述动作的执行情况以及约束信息等。一个典型的例子就是用于说明一个消息是重复发送的。另外,可以定义两个消息间的时间限制。</p>

<p align="left"><br>
一个对象可以通过发送消息来创建另一个对象,当一个对象被删除或自我删除时,该对象用&quot;X&quot;标识。</p>

<p align="left"><br>
另外,在很多算法中,递归是一种很重要的技术。当一个操作直接或间接调用自身时,即发生了递归。产生递归的消息总是同步消息,返回消息应是一个简单消息。</p>

<p align="left"><br>
4. 合作图</p>

<p align="left"><br>
合作图(Collaboration Diagram)用于描述相互合作的对象间的交互关系和链接关系。虽然顺序图和合作图都用来描述对象间的交互关系,但侧重点不一样。顺序图着重体现交互的时间顺序,合作图则着重体现交互对象间的静态链接关系。</p>

<p align="left"><br>
合作图中对象的外观与顺序图中的一样。如果一个对象在消息的交互中被创建,则可在对象名称之后标以{new}。类似地,如果一个对象在交互期间被删除,则可在对象名称之后标以{destroy}。对象间的链接关系类似于类图中的联系(但无多重性标志)。通过在对象间的链接上标志带有消息串的消息(简单、异步或同步消息)来表达对象间的消息传递。</p>

<p align="left"><br>
(1) 链接　链接用于表示对象间的各种关系,包括组成关系的链接(Composition
Li nk)、聚集关系的链接(Aggregation Link)、限定关系的链接(Qualified
Link)以及导航链接(Navigation Link)。各种链接关系与类图中的定义相同,在链接的端点位置可以显示对象的角色名和模板信息。</p>

<p align="left"><br>
(2) 消息流　在合作图的链接线上,可以用带有消息串的消息来描述对象间的交互。消息的箭头指明消息的流动方向。消息串说明要发送的消息、消息的参数、消息的返回值以及消息的序列号等信息(未完待续)。<br>
</p>

<p align="center"><a href="../index.htm">Home</a></p>
</body>
</html>
