<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>am::mate: Use am::lambda to compose a function object.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="index.html">Writing an exception safe code in generic way.</a></div>
<h1><a class="anchor" name="mate_use_lambda">Use am::lambda to compose a function object.</a></h1><code>boost::lambda</code> library provide a very powerful ability to create an anonymous function object on the spot. Unfortunately it does not support some outdated compilers which are still widely being used. In such environment, you can consider to use <a class="el" href="namespaceam_1_1lambda.html">am::lambda</a>.<p>
<a class="el" href="namespaceam_1_1lambda.html">am::lambda</a> is a limited subset of <code>boost::lambda</code> which only supports the following operators.<p>
<ul>
<li>Logical NOT : !</li><li>Logical AND : &amp;&amp;</li><li>Logical OR : ||</li><li>Equality operators : ==, !=</li><li>Relational operators : &lt;, &gt;, &lt;=, &gt;=</li><li>Address-of operator : &amp;</li><li>Pointer-to-member operator : -&gt;* (to access member data pointer, not member function pointer and read-only access)</li></ul>
<p>
The above lambda operators seems good enough to collaborate with <a class="el" href="classam_1_1mate.html">am::mate</a> and, most of all, it might work for those outdated compiler which <code>boost::lambda</code> does not support.<p>
Also <a class="el" href="namespaceam_1_1lambda.html#794d3c4a2b7231c36cfc0684fea9bf5e">am::lambda::bind</a> overloaded helper template functions are provided to support arguments binding similar to <code>boost::lambda::bind</code>.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include "<a class="code" href="mate_8hpp.html">mate.hpp</a>"</span>
<span class="preprocessor"> #include "<a class="code" href="lambda_8hpp.html">lambda.hpp</a>"</span>

 <span class="keyword">class </span>Graph { };

 std::pair&lt;bool, unsigned&gt; AddVertex(Graph &amp; g)
 {
   <span class="keywordtype">bool</span> is_success = <span class="keyword">false</span>;
   <span class="keywordtype">unsigned</span> vertex_descriptor = 0;

   <span class="comment">// Add a new vertex.</span>

   <span class="comment">// return Pair of boolean success flag and the new vertex descriptor if it</span>
   <span class="comment">// successfully added a new vertex.</span>
   <span class="keywordflow">return</span> std::make_pair( is_success, vertex_descriptor );
 }

 <span class="keywordtype">void</span> RemoveVertex(<span class="keywordtype">unsigned</span> vertex_descriptor, Graph &amp; g)
 {
   <span class="comment">// Remove the vertex of the specified descriptor.</span>
 }

 <span class="keywordtype">void</span> test20(Graph &amp; g)
 {
   <span class="keyword">typedef</span> std::pair&lt;bool, unsigned&gt; result_pair;

   <span class="comment">// 1. Calls the host function AddVertex()</span>
   <span class="comment">// 2. Mates RemoveVertex() with the second of the resultant std::pair of the host function</span>
   <span class="comment">//    only if the first of the resultant std::pair of the host functio hold true.</span>
   <a class="code" href="mate_8hpp.html#9017d939bd69b57ffa03347874ac607b">MATE_IF</a>( AddVertex( g ),
     <a class="code" href="namespaceam_1_1lambda.html#794d3c4a2b7231c36cfc0684fea9bf5e">am::lambda::bind</a>( &amp;RemoveVertex, &amp;<a class="code" href="namespaceam_1_1lambda.html#46cdab44274e0a15a02179cade2f0bb4">am::lambda::_1</a>-&gt;*&amp;result_pair::second, g ), 
     &amp;<a class="code" href="namespaceam_1_1lambda.html#46cdab44274e0a15a02179cade2f0bb4">am::lambda::_1</a>-&gt;*&amp;result_pair::first );
  }
</pre></div><p>
<a class="el" href="namespaceam_1_1lambda.html#794d3c4a2b7231c36cfc0684fea9bf5e">am::lambda::bind</a> can resolve overloaded free functions (non-member functions) with <code>__stdcall</code> calling convention when AM_ENABLE_BIND_STDCALL is defined before including, directly or indirectly, "lambda.hpp". <a class="el" href="namespaceam_1_1lambda.html#794d3c4a2b7231c36cfc0684fea9bf5e">am::lambda::bind</a> supports binding only up to 3 input arguments.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include "<a class="code" href="mate_8hpp.html">mate.hpp</a>"</span>

<span class="preprocessor"> #define AM_BIND_ENABLE_STDCALL</span>
<span class="preprocessor"></span><span class="preprocessor"> #include "<a class="code" href="lambda_8hpp.html">lambda.hpp</a>"</span>

 <span class="keyword">typedef</span> std::map&lt;int, RECT&gt; RECT_MAP; <span class="comment">// Rect id -&gt; Rectangle</span>
 <span class="keyword">typedef</span> RECT_MAP::value_type MAP_VALUE;

 MAP_VALUE ModifyRectangle(MAP_VALUE map_value) { <span class="keywordflow">return</span> map_value; }
 <span class="keywordtype">void</span> UndoRectangle(<span class="keywordtype">int</span> rect_id) { }

 <span class="keywordtype">void</span> test21(RECT_MAP <span class="keyword">const</span> &amp; rect_map, POINT pt)
 {
   RECT_MAP::const_iterator it = rect_map.begin(), it_e = rect_map.end();
   <span class="keywordflow">for</span>( ; it != it_e; ++it )
   {
     <span class="comment">// 1. Calls the host function ModifyRectangle()</span>
     <span class="comment">// 2. Mates UndoRectangle() with the first of the iterating map value that</span>
     <span class="comment">//    host function returns, only if the rectangle is found to contain the</span>
     <span class="comment">//    specified point and the specified point is not the origin (0, 0).</span>
     <a class="code" href="mate_8hpp.html#9017d939bd69b57ffa03347874ac607b">MATE_IF</a>( ModifyRectangle( *it ),
       <a class="code" href="namespaceam_1_1lambda.html#794d3c4a2b7231c36cfc0684fea9bf5e">am::lambda::bind</a>( &amp;UndoRectangle, &amp;<a class="code" href="namespaceam_1_1lambda.html#46cdab44274e0a15a02179cade2f0bb4">am::lambda::_1</a>-&gt;*&amp;MAP_VALUE::first ),
       <a class="code" href="namespaceam_1_1lambda.html#794d3c4a2b7231c36cfc0684fea9bf5e">am::lambda::bind</a>( &amp;::PtInRect, &amp;( &amp;<a class="code" href="namespaceam_1_1lambda.html#46cdab44274e0a15a02179cade2f0bb4">am::lambda::_1</a>-&gt;*&amp;MAP_VALUE::second ), pt ) &amp;&amp;
       <a class="code" href="structam_1_1lambda_1_1condition.html">am::lambda::condition</a>( 0 != pt.x &amp;&amp; 0 != pt.y ) );
   }
 }
</pre></div><p>
<a class="el" href="namespaceam_1_1lambda.html">am::lambda</a> is completely independent on <a class="el" href="classam_1_1mate.html">am::mate</a> and vice-versa, thus both can be used separately.<p>
<a class="el" href="index.html#mate_contents">[Contents]</a> <hr size="1"><address style="align: right;"><small>Generated on Sat Dec 16 22:27:43 2006 for am::mate by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
