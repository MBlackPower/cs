<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>am::mate: Introduction.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="index.html">Writing an exception safe code in generic way.</a></div>
<h1><a class="anchor" name="mate_introduction">Introduction.</a></h1>Here is an example of a traditional scenario in our daily programming as shown below. We are prone to forget to call some clean up codes when the function has multiple return paths or an exception is thrown in the middle of very complicated constructs.<p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> test01()
 {
  <span class="keywordtype">char</span> <span class="keyword">const</span> * lpszFilePath = <span class="stringliteral">"c:\\test.dat"</span>;

  HANDLE hFile( ::CreateFile( lpszFilePath, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL ) );

  <span class="keywordflow">if</span>( INVALID_HANDLE_VALUE != hFile )
  {

    <span class="keywordflow">if</span>( 100 &gt; ::GetFileSize( hFile, NULL ) )
      <span class="keywordflow">throw</span> <span class="stringliteral">"File size too small!"</span>;

    ::CloseHandle( hFile );
  }

  ::DeleteFile( lpszFilePath );
 }
</pre></div><p>
<code>boost::shared_ptr</code> can be used to transform the code snippet above in exception safe way. It purely depends on the ability of the <code>boost::shared_ptr</code> that it allows for user to provide a custom deleter function object. See more details from <a href="http://www.codeproject.com/vcpp/stl/boostsp_handleref.asp">here</a>.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #define BOOST_BIND_ENABLE_STDCALL</span>
<span class="preprocessor"></span><span class="preprocessor"> #include &lt;boost/bind.hpp&gt;</span>
<span class="preprocessor"> #include &lt;boost/shared_ptr.hpp&gt;</span>

 <span class="keywordtype">void</span> test02()
 {
   boost::shared_ptr&lt;char const&gt; spFilePath( <span class="stringliteral">"c:\\test.dat"</span>, &amp;::DeleteFile );

   boost::shared_ptr&lt;void&gt; spFile(
    ::CreateFile( spFilePath.get(), GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL ),
    &amp;::CloseHandle ); <span class="comment">// Custom deleter.</span>

   <span class="keywordflow">if</span>( INVALID_HANDLE_VALUE != spFile.get() )
   {

     <span class="keywordflow">if</span>( 100 &gt; ::GetFileSize( spFile.get(), NULL ) )
       <span class="keywordflow">throw</span> <span class="stringliteral">"File size too small!"</span>;
   }
 }
</pre></div><p>
Writing a code in the exception safe way at object level doesn't require the fancy reference counting feature of <code>boost::shared_ptr</code>, but only requires that of the custom deleter function object. Speaking accurately, what we need is an ability to call an arbitrary custom function object in the destructor of our class variable when it goes out of scope. By extracting and combining merits of the existing implementations such as <code>boost::shared_ptr</code>, <code>ScopeGuard</code> and etc., here I will like to introduce a small <a class="el" href="classam_1_1mate.html">am::mate</a> utility class.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include "mate.h"</span>

 <span class="keywordtype">void</span> test03()
 {
   <a class="code" href="classam_1_1mate.html">am::mate&lt;char const *&gt;</a> lpszFilePath( <span class="stringliteral">"c:\\test.dat"</span>, &amp;::DeleteFile );

   <a class="code" href="classam_1_1mate.html">am::mate&lt;HANDLE&gt;</a> hFile(
    ::CreateFile( lpszFilePath, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL ), <span class="comment">// Host function.</span>
    &amp;::CloseHandle,                                                             <span class="comment">// Mate function.</span>
    (HANDLE)INVALID_HANDLE_VALUE != <a class="code" href="namespaceam_1_1lambda.html#46cdab44274e0a15a02179cade2f0bb4">am::lambda::_1</a> ); <span class="comment">// Mates the function only if the condition asserts true.</span>

   <span class="comment">// Treats am::mate&lt;HANDLE&gt; as if it is a HANDLE.</span>
   <span class="keywordflow">if</span>( INVALID_HANDLE_VALUE != hFile )
   {

     <span class="keywordflow">if</span>( 100 &gt; ::GetFileSize( hFile, NULL ) )
       <span class="keywordflow">throw</span> <span class="stringliteral">"File size too small"</span>;
   }
 }
</pre></div><p>
There are several benefits of using <a class="el" href="classam_1_1mate.html">am::mate</a> over the existing implementations.<p>
<ol type=1>
<li>More intuitive and well defined interfaces.</li><li>Accepts any unary custom mate function object which takes the return of the host function as its argument.</li><li>Not like <code>boost::shared_ptr</code> is limited only for the pointer type, <a class="el" href="classam_1_1mate.html">am::mate</a> works with any data type. i.e. intergral type, floating point type, pointer type and even reference type.</li><li>Implicit conversion to the return type of the host function which cast an illusion that makes an <a class="el" href="classam_1_1mate.html">am::mate</a> instance as if it is a stored variable of the return type of the host function.</li><li>Easy, convenient and compiler-warning-free <a class="el" href="mate_8hpp.html#01562e931d80813b43fcddc1a13799fe">MATE()</a> macro definitions to create an anonymous <a class="el" href="classam_1_1mate.html">am::mate</a> variable.</li><li>Mates functions with a condition.</li><li>Provides a simple set of boolean lambda operations to support composing an anonymous function object for the condition.</li><li><a class="el" href="classam_1_1mate_3_01void_01_4.html">am::mate&lt;void&gt;</a> specialization when mating a mate function object without any host function call.</li><li>Well standard compliant and portable. Tested on VC6, VC71, VC80, gcc3.4.2.</li><li>No dependency on boost library but works nicely with it.</li><li>Provide <a class="el" href="namespaceam.html#075d855cc1ab6d87a818e72ed34bc829">am::ptr_fun</a>, <a class="el" href="namespaceam.html#5d35d0139360afc672d2cf1ff279fd83">am::bind1st</a> and <a class="el" href="namespaceam.html#7416ae43749c6a8c08f3a1f8760ae24f">am::bind2nd</a> helper template functions that work well for any calling convention (including <code>__stdcall</code>).</li><li><a class="el" href="namespaceam_1_1lambda.html#794d3c4a2b7231c36cfc0684fea9bf5e">am::lambda::bind</a> up to 3 arguments for both free function and member function are provided.</li></ol>
<p>
<a class="el" href="index.html#mate_contents">[Contents]</a> <hr size="1"><address style="align: right;"><small>Generated on Sat Dec 16 22:27:43 2006 for am::mate by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
