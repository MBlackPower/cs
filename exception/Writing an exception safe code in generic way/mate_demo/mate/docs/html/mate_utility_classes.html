<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>am::mate: Utility classes and their helper template functions.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="index.html">Writing an exception safe code in generic way.</a></div>
<h1><a class="anchor" name="mate_utility_classes">Utility classes and their helper template functions.</a></h1><h2><a class="anchor" name="mate_uc_s1">
Supporting parameter by reference: am::ref and am::cref.</a></h2>
Specifies the reference type as the template argument of the <a class="el" href="classam_1_1mate.html">am::mate</a> class if you want to provide the return of the host function as a reference to the mate function.<p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> &amp; Increase(<span class="keywordtype">int</span> &amp; x) { <span class="keywordflow">return</span> ++x; }
 <span class="keywordtype">void</span> Decrease(<span class="keywordtype">int</span> &amp; x) { --x; }

 <span class="keywordtype">void</span> test15(<span class="keywordtype">int</span> &amp; refCount)
 {
   <a class="code" href="classam_1_1mate.html">am::mate&lt;int &amp;&gt;</a> decreseOnExit( Increase( refCount ), &amp;Decrease );

 } <span class="comment">//  Calls Decrease( refCount ) on exit.</span>
</pre></div><p>
By default, a template parameter is passed by value, not by reference. Thus if a mate function provided wants to take the return of the host function as a reference and <a class="el" href="mate_8hpp.html#01562e931d80813b43fcddc1a13799fe">MATE()</a> macro definition is used, the specified mate function will be called with the reference to the "copy" of the argument, not with the reference to argument itself, when it goes out of scope since template parameter is passed by value. Use <a class="el" href="namespaceam.html#aeac214784a5e1a16be743677555cb96">am::ref</a> or <a class="el" href="namespaceam.html#10096add639d0ba375c58c53aa8ff4a7">am::cref</a> function to specify explicitly to use <a class="el" href="classam_1_1ref__holder.html">am::ref_holder</a> class transforms a reference into a value.<p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> test16(<span class="keywordtype">int</span> &amp; refCount)
 {
   <a class="code" href="mate_8hpp.html#01562e931d80813b43fcddc1a13799fe">MATE</a>( <a class="code" href="namespaceam.html#aeac214784a5e1a16be743677555cb96">am::ref</a>( Increase( refCount ) ), &amp;Decrease );

 }  <span class="comment">//  Calls Decrease( refCount ) on exit.</span>
</pre></div><h3><a class="anchor" name="mate_uc_s2">
Free function pointer: am::ptr_fun.</a></h3>
<a class="el" href="namespaceam.html#075d855cc1ab6d87a818e72ed34bc829">am::ptr_fun</a> is very similar to <code>std::ptr_fun</code> that it is used to convert unary and binary function pointers, respectively, into unary and binary adaptable function objects. However they are different in that <a class="el" href="namespaceam.html#075d855cc1ab6d87a818e72ed34bc829">am::ptr_fun</a> can convert the function pointers of any calling covention while <code>std::ptr_fun</code> can only convert <code>__cdecl</code> function pointers. In general, use <code>std::ptr_fun</code> and ignore <a class="el" href="namespaceam.html#075d855cc1ab6d87a818e72ed34bc829">am::ptr_fun</a> if you don't concern about calling convention.<p>
<a class="el" href="namespaceam.html#075d855cc1ab6d87a818e72ed34bc829">am::ptr_fun</a> and other helper template functions of <a class="el" href="classam_1_1mate.html">am::mate</a> are designed to collaborate only with <a class="el" href="classam_1_1mate.html">am::mate</a> and its other sibling helper template functions so do not mix use it with helper template functions from STL (such as <code>std::ptr_fun</code>, <code>std::bind1st</code>, <code>std::bind2nd</code> and so on.)<p>
You can also use <a class="el" href="namespaceam.html#075d855cc1ab6d87a818e72ed34bc829">am::ptr_fun</a> to resolve overloaded functions manually since the template rules are very strict for type checking and it is not supposed to resolve the resolution of the overloaded functions automatically.<p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Overloaded functions</span>
 <span class="keywordtype">void</span> foo(<span class="keywordtype">char</span> <span class="keyword">const</span> *, <span class="keywordtype">int</span>) { }
 <span class="keywordtype">void</span> foo(<span class="keywordtype">int</span>) { }
 <span class="keywordtype">void</span> __stdcall foo(<span class="keywordtype">char</span> <span class="keyword">const</span> *) { }

 <span class="keywordtype">void</span> __stdcall bar(<span class="keywordtype">char</span> <span class="keyword">const</span> *) { }

 <span class="keywordtype">void</span> test17()
 {
   <span class="comment">// Provides function template parameter explicitly to resolve overloaded functions.</span>
   <a class="code" href="mate_8hpp.html#01562e931d80813b43fcddc1a13799fe">MATE</a>( <span class="stringliteral">"Hello foo!"</span>, <a class="code" href="namespaceam.html#075d855cc1ab6d87a818e72ed34bc829">am::ptr_fun</a>&lt;<span class="keywordtype">void</span> (_stdcall *)(<span class="keywordtype">char</span> <span class="keyword">const</span> *)&gt;( &amp;foo ) );
   <a class="code" href="mate_8hpp.html#01562e931d80813b43fcddc1a13799fe">MATE</a>( <span class="stringliteral">"Hello foo!"</span>, <a class="code" href="namespaceam.html#7416ae43749c6a8c08f3a1f8760ae24f">am::bind2nd</a>( <a class="code" href="namespaceam.html#075d855cc1ab6d87a818e72ed34bc829">am::ptr_fun</a>&lt;<span class="keywordtype">void</span> (*)(<span class="keywordtype">char</span> <span class="keyword">const</span> *, <span class="keywordtype">int</span>)&gt;( &amp;foo ), 123 ) );

   <span class="comment">// am::pointer_to_function is not necessary,</span>
   <span class="comment">// unless otherwise resolving overloaded functions is required.</span>
   <a class="code" href="mate_8hpp.html#01562e931d80813b43fcddc1a13799fe">MATE</a>( <span class="stringliteral">"Hello bar!"</span>, <a class="code" href="namespaceam.html#075d855cc1ab6d87a818e72ed34bc829">am::ptr_fun</a>( &amp;bar ) );
   <a class="code" href="mate_8hpp.html#01562e931d80813b43fcddc1a13799fe">MATE</a>( <span class="stringliteral">"Hello bar!"</span>, &amp;bar );
 }
</pre></div><p>
Be aware that the template parameter is provided as a single function pointer not as individual types from the function signature like STL does. It gives <a class="el" href="namespaceam.html#075d855cc1ab6d87a818e72ed34bc829">am::ptr_fun</a> and its sibling helper template functions the ability to resolve overloaded functions better as well as to work well with any calling conventions but it also prevents from being able to define the public interfaces such as <code>first_argument_type</code>, <code>second_argument_type</code> and <code>result_type</code>. Actually <code>result_type</code> is always fixed and defined as void internally since <a class="el" href="classam_1_1mate.html">am::mate</a> does not utilize the <code>result_type</code> under the hood.<p>
<b>- NOTE -</b><p>
<em>Do <b>NOT</b> use <a class="el" href="namespaceam.html#075d855cc1ab6d87a818e72ed34bc829">am::ptr_fun</a>, <a class="el" href="namespaceam.html#5d35d0139360afc672d2cf1ff279fd83">am::bind1st</a>, <a class="el" href="namespaceam.html#7416ae43749c6a8c08f3a1f8760ae24f">am::bind2nd</a> to create a function object which wraps a free function with the calling convention other than <code>__cdecl</code> under none-MSVC environment. Calling convention is subject to be a platform specific therefore it does not work well for none-MSVC environment, especially when function pointer is passed as a template parameter. Use <a class="el" href="namespaceam_1_1lambda.html#794d3c4a2b7231c36cfc0684fea9bf5e">am::lambda::bind</a> instead.</em><h3><a class="anchor" name="mate_uc_s3">
Bind the 1st or the 2nd argument of the binary function: am::bind1st and am::bind2nd.</a></h3>
<a class="el" href="namespaceam.html#5d35d0139360afc672d2cf1ff279fd83">am::bind1st</a> and <a class="el" href="namespaceam.html#7416ae43749c6a8c08f3a1f8760ae24f">am::bind2nd</a> are similar to <code>std::bind1st</code> and <code>std::bind2nd</code> respectively but they resolve overloaded functions better as well as work for any calling conventions at the expense of not having public interface <code>first_argument_type</code>. The template parameter is also required to be provided as a single function pointer not as individual types from the function signature when resolving overloaded functions is needed.<p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> foo(<span class="keywordtype">char</span> <span class="keyword">const</span> *, <span class="keywordtype">int</span>) { }
 <span class="keywordtype">void</span> __stdcall bar(<span class="keywordtype">char</span> <span class="keyword">const</span> *, <span class="keywordtype">int</span>) { }  <span class="comment">// __stdcall calling convention.</span>

 <span class="keywordtype">void</span> main()
 {
   <span class="comment">// MATE( "Hello foo!", std::bind2nd( &amp;foo, 123 ) ); // Compiles error!</span>
   <span class="comment">// MATE( "Hello bar!", std::bind2nd( &amp;bar, 123 ) ); // Compiles error!</span>
   <a class="code" href="mate_8hpp.html#01562e931d80813b43fcddc1a13799fe">MATE</a>( <span class="stringliteral">"Hello foo!"</span>, <a class="code" href="namespaceam.html#7416ae43749c6a8c08f3a1f8760ae24f">am::bind2nd</a>( &amp;foo, 123 ) ); <span class="comment">// Compiles OK!</span>
   <a class="code" href="mate_8hpp.html#01562e931d80813b43fcddc1a13799fe">MATE</a>( <span class="stringliteral">"Hello bar!"</span>, <a class="code" href="namespaceam.html#7416ae43749c6a8c08f3a1f8760ae24f">am::bind2nd</a>( &amp;bar, 123 ) ); <span class="comment">// Compiles OK!</span>
 }
</pre></div><h3><a class="anchor" name="mate_uc_s4">
Miscellaneous.</a></h3>
<a class="el" href="structam_1_1condition.html">am::condition</a> can be used to convert a boolean expression into a null-nary or unary predicate.<p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> test19(<span class="keywordtype">bool</span> cond)
 {
   assert( <span class="keyword">false</span> == <a class="code" href="structam_1_1condition.html">am::condition</a>( 2 == 3 )() );
   assert( <span class="keyword">false</span> == <a class="code" href="structam_1_1condition.html">am::condition</a>( 2 == 3 )( <span class="stringliteral">"123"</span> ) );  <span class="comment">// Input argument is simply ignored.</span>

   <span class="comment">// Use am::lambda::condition instead when composing a function object using am::lambda</span>
   <a class="code" href="mate_8hpp.html#9017d939bd69b57ffa03347874ac607b">MATE_IF</a>( ::CreateMutex(NULL, TRUE, NULL), &amp;::ReleaseMutex,
     (HANDLE)NULL != <a class="code" href="namespaceam_1_1lambda.html#46cdab44274e0a15a02179cade2f0bb4">am::lambda::_1</a> &amp;&amp; <a class="code" href="structam_1_1lambda_1_1condition.html">am::lambda::condition</a>( cond ) );
 } 
</pre></div><p>
<a class="el" href="index.html#mate_contents">[Contents]</a> <hr size="1"><address style="align: right;"><small>Generated on Sat Dec 16 22:27:43 2006 for am::mate by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
