<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>am::mate: mate.hpp File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>mate.hpp File Reference</h1>Writing an exception safe code in generic way. <a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceam.html">am</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><b>am::detail</b></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classam_1_1detail_1_1mate__base.html">am::detail::mate_base</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classam_1_1detail_1_1simple__ptr__holder.html">am::detail::simple_ptr_holder</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>am::detail::simple_ptr_holder::typed_&lt; T &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classam_1_1mate.html">am::mate&lt; R &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mates a host function with the mate function object.  <a href="classam_1_1mate.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structam_1_1mate_1_1typed__.html">am::mate&lt; R &gt;::typed_&lt; T &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classam_1_1mate_3_01void_01_4.html">am::mate&lt; void &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">void template specialization for mate.  <a href="classam_1_1mate_3_01void_01_4.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structam_1_1mate_3_01void_01_4_1_1typed__.html">am::mate&lt; void &gt;::typed_&lt; T &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structam_1_1condition.html">am::condition</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Predicate.  <a href="structam_1_1condition.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classam_1_1ref__holder.html">am::ref_holder&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reference holder.  <a href="classam_1_1ref__holder.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structam_1_1pointer__to__function.html">am::pointer_to_function&lt; Fn &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function pointer to an unary function or a binary function.  <a href="structam_1_1pointer__to__function.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structam_1_1binder1st.html">am::binder1st&lt; Op, P1 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind the 1st argument of a binary function.  <a href="structam_1_1binder1st.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structam_1_1binder2nd.html">am::binder2nd&lt; Op, P2 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind the 2nd argument of a binary function.  <a href="structam_1_1binder2nd.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3e4350f057eab99f651bf44d03762124"></a><!-- doxytag: member="mate.hpp::__MATE_HPP__INCLUDED__" ref="3e4350f057eab99f651bf44d03762124" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>__MATE_HPP__INCLUDED__</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f20ae84ff5fe6051ab485fe2188d1764"></a><!-- doxytag: member="mate.hpp::AM_JOIN" ref="f20ae84ff5fe6051ab485fe2188d1764" args="(a, b)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>AM_JOIN</b>(a, b)&nbsp;&nbsp;&nbsp;AM_DO_JOIN(a, b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ef14a56f5094b52719cef7b4babbb19c"></a><!-- doxytag: member="mate.hpp::AM_DO_JOIN" ref="ef14a56f5094b52719cef7b4babbb19c" args="(a, b)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>AM_DO_JOIN</b>(a, b)&nbsp;&nbsp;&nbsp;AM_DO_JOIN2(a, b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="252890d60fe1730841c5a00489165ec4"></a><!-- doxytag: member="mate.hpp::AM_DO_JOIN2" ref="252890d60fe1730841c5a00489165ec4" args="(a, b)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>AM_DO_JOIN2</b>(a, b)&nbsp;&nbsp;&nbsp;a##b</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mate_8hpp.html#0b43846b9d4b2cf0017afdb28a0fdda6">AM_ANONYMOUS_MATE</a>(HOST_FN, MATE_FN, UNIQUE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mate_8hpp.html#a986ab16c039b02db09e4da015c65a0d">AM_ANONYMOUS_MATE_IF</a>(HOST_FN, MATE_FN, COND, UNIQUE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mate_8hpp.html#b96c3730f55e6042664d206492749cf3">AM_ANONYMOUS_MATE_VOID</a>(MATE_FN, UNIQUE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mate_8hpp.html#034dce381d7a40e6b85afa5fc84ed86d">AM_ANONYMOUS_MATE_VOID_IF</a>(MATE_FN, COND, UNIQUE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mate_8hpp.html#01562e931d80813b43fcddc1a13799fe">MATE</a>(HOST_FN, MATE_FN)&nbsp;&nbsp;&nbsp;AM_ANONYMOUS_MATE(HOST_FN, MATE_FN, __LINE__)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mate_8hpp.html#9017d939bd69b57ffa03347874ac607b">MATE_IF</a>(HOST_FN, MATE_FN, COND)&nbsp;&nbsp;&nbsp;AM_ANONYMOUS_MATE_IF(HOST_FN, MATE_FN, COND, __LINE__)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mate_8hpp.html#b64fb21cccc9097c72ddab9f2c37d78a">MATE_VOID</a>(MATE_FN)&nbsp;&nbsp;&nbsp;AM_ANONYMOUS_MATE_VOID(MATE_FN, __LINE__)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mate_8hpp.html#becd3ca3f114b18666fd383aad100fef">MATE_VOID_IF</a>(MATE_FN, COND)&nbsp;&nbsp;&nbsp;AM_ANONYMOUS_MATE_VOID_IF(MATE_FN, COND, __LINE__)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mate_8hpp.html#19fc8b71e7a27de46d8a4a8c7ef8c3ff">MATE_</a>(N, HOST_FN, MATE_FN)&nbsp;&nbsp;&nbsp;MATE(HOST_FN, MATE_FN)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mate_8hpp.html#4cca2d4ba772910bd738c660c1a8348e">MATE_IF_</a>(N, HOST_FN, MATE_FN, COND)&nbsp;&nbsp;&nbsp;MATE_IF(HOST_FN, MATE_FN, COND)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mate_8hpp.html#c8c88f0150b222ce2afb082872d36918">MATE_VOID_</a>(N, MATE_FN)&nbsp;&nbsp;&nbsp;MATE_VOID(MATE_FN)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mate_8hpp.html#35d3c430642a21a853b08f966bb16895">MATE_VOID_IF_</a>(N, MATE_FN, COND)&nbsp;&nbsp;&nbsp;MATE_VOID_IF(MATE_FN, COND)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class R, class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mate&lt; R &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceam.html#5bba945b6b915ffa8ef360461257995c">am::make_mate</a> (R ret, T mate_functor)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class R, class T, class C&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">mate&lt; R &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceam.html#0f8dd60a87bce90c886e49a64c2fdb1e">am::make_mate</a> (R ret, T mate_functor, C mate_if)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ref_holder&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceam.html#aeac214784a5e1a16be743677555cb96">am::ref</a> (T &amp;ref)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ref_holder&lt; T const &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceam.html#10096add639d0ba375c58c53aa8ff4a7">am::cref</a> (T const &amp;ref)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Fn&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">pointer_to_function&lt; Fn &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceam.html#075d855cc1ab6d87a818e72ed34bc829">am::ptr_fun</a> (Fn const fn)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Op, typename P1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">binder1st&lt; Op, P1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceam.html#5d35d0139360afc672d2cf1ff279fd83">am::bind1st</a> (Op const &amp;op, P1 p1)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Op, typename P2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">binder2nd&lt; Op, P2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceam.html#7416ae43749c6a8c08f3a1f8760ae24f">am::bind2nd</a> (Op const &amp;op, P2 p2)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Writing an exception safe code in generic way. 
<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>JaeWook Choi (zzzz.ooo "at' gmail.com) </dd></dl>
<dl class="version" compact><dt><b>Version:</b></dt><dd>1.02 </dd></dl>
<dl class="date" compact><dt><b>Date:</b></dt><dd>12.12.2006 </dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>This software is provided "as is" without express or implied warranty. <p>
Use it at your own risk! </dd></dl>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="0b43846b9d4b2cf0017afdb28a0fdda6"></a><!-- doxytag: member="mate.hpp::AM_ANONYMOUS_MATE" ref="0b43846b9d4b2cf0017afdb28a0fdda6" args="(HOST_FN, MATE_FN, UNIQUE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AM_ANONYMOUS_MATE          </td>
          <td>(</td>
          <td class="paramtype">HOST_FN,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATE_FN,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UNIQUE&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="classam_1_1detail_1_1mate__base.html">am::detail::mate_base</a> <span class="keyword">const</span> &amp; AM_JOIN(_anonymous_, UNIQUE) = \
  <a class="code" href="namespaceam.html#5bba945b6b915ffa8ef360461257995c">am::make_mate</a>((HOST_FN), (MATE_FN)); AM_JOIN(_anonymous_, UNIQUE);
</pre></div><p><b>For internal use only.</b></p>
<p>
Generates anonymous mate variable. </p>

</div>
</div><p>
<a class="anchor" name="a986ab16c039b02db09e4da015c65a0d"></a><!-- doxytag: member="mate.hpp::AM_ANONYMOUS_MATE_IF" ref="a986ab16c039b02db09e4da015c65a0d" args="(HOST_FN, MATE_FN, COND, UNIQUE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AM_ANONYMOUS_MATE_IF          </td>
          <td>(</td>
          <td class="paramtype">HOST_FN,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATE_FN,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COND,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UNIQUE&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="classam_1_1detail_1_1mate__base.html">am::detail::mate_base</a> <span class="keyword">const</span> &amp; AM_JOIN(_anonymous_if_, UNIQUE) = \
  <a class="code" href="namespaceam.html#5bba945b6b915ffa8ef360461257995c">am::make_mate</a>((HOST_FN), (MATE_FN), (COND)); AM_JOIN(_anonymous_if_, UNIQUE);
</pre></div><p><b>For internal use only.</b></p>
<p>
Generates anonymous mate variable with a condition. </p>

</div>
</div><p>
<a class="anchor" name="b96c3730f55e6042664d206492749cf3"></a><!-- doxytag: member="mate.hpp::AM_ANONYMOUS_MATE_VOID" ref="b96c3730f55e6042664d206492749cf3" args="(MATE_FN, UNIQUE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AM_ANONYMOUS_MATE_VOID          </td>
          <td>(</td>
          <td class="paramtype">MATE_FN,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UNIQUE&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="classam_1_1mate.html">am::mate&lt;void&gt;</a> AM_JOIN(_anonymous_void_, UNIQUE)((MATE_FN)); \
 AM_JOIN(_anonymous_void_, UNIQUE);
</pre></div><p><b>For internal use only.</b></p>
<p>
Generates anonymous mate&lt;void&gt; variable. </p>

</div>
</div><p>
<a class="anchor" name="034dce381d7a40e6b85afa5fc84ed86d"></a><!-- doxytag: member="mate.hpp::AM_ANONYMOUS_MATE_VOID_IF" ref="034dce381d7a40e6b85afa5fc84ed86d" args="(MATE_FN, COND, UNIQUE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AM_ANONYMOUS_MATE_VOID_IF          </td>
          <td>(</td>
          <td class="paramtype">MATE_FN,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COND,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UNIQUE&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="classam_1_1mate.html">am::mate&lt;void&gt;</a> AM_JOIN(_anonymous_void_if_, UNIQUE)((MATE_FN), (COND)); \
 AM_JOIN(_anonymous_void_if_, UNIQUE);
</pre></div><p><b>For internal use only.</b></p>
<p>
Generates anonymous mate&lt;void&gt; variable with a condition. </p>

</div>
</div><p>
<a class="anchor" name="01562e931d80813b43fcddc1a13799fe"></a><!-- doxytag: member="mate.hpp::MATE" ref="01562e931d80813b43fcddc1a13799fe" args="(HOST_FN, MATE_FN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MATE          </td>
          <td>(</td>
          <td class="paramtype">HOST_FN,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATE_FN&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;AM_ANONYMOUS_MATE(HOST_FN, MATE_FN, __LINE__)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an anonymous (unnamed) mate variable which calls the mate function object, <em>MATE_FN</em> in its destructor with the return of the host function, <em>HOST_FN</em> as its argument when it goes out of scope.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="mate_8hpp.html#0b43846b9d4b2cf0017afdb28a0fdda6">AM_ANONYMOUS_MATE()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="19fc8b71e7a27de46d8a4a8c7ef8c3ff"></a><!-- doxytag: member="mate.hpp::MATE_" ref="19fc8b71e7a27de46d8a4a8c7ef8c3ff" args="(N, HOST_FN, MATE_FN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MATE_          </td>
          <td>(</td>
          <td class="paramtype">N,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HOST_FN,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATE_FN&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MATE(HOST_FN, MATE_FN)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
It is devised to remedy the issue that some compiler can't generate an unique anonymous variable. In such compiler, user must provide an unique number <em>N</em> to create an unique identifier manually. In other compilers, it is identical to <a class="el" href="mate_8hpp.html#01562e931d80813b43fcddc1a13799fe">MATE()</a> and <em>N</em> is simply ignored.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="mate_8hpp.html#01562e931d80813b43fcddc1a13799fe">MATE()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9017d939bd69b57ffa03347874ac607b"></a><!-- doxytag: member="mate.hpp::MATE_IF" ref="9017d939bd69b57ffa03347874ac607b" args="(HOST_FN, MATE_FN, COND)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MATE_IF          </td>
          <td>(</td>
          <td class="paramtype">HOST_FN,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATE_FN,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COND&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;AM_ANONYMOUS_MATE_IF(HOST_FN, MATE_FN, COND, __LINE__)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an anonymous (unnamed) mate variable which calls the mate function object, <em>MATE_FN</em> in its destructor with the return of the host function <em>HOST_FN</em> as its argument when it goes out of scope only if the unary predicate, <em>COND</em> asserts true.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="mate_8hpp.html#a986ab16c039b02db09e4da015c65a0d">AM_ANONYMOUS_MATE_IF()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4cca2d4ba772910bd738c660c1a8348e"></a><!-- doxytag: member="mate.hpp::MATE_IF_" ref="4cca2d4ba772910bd738c660c1a8348e" args="(N, HOST_FN, MATE_FN, COND)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MATE_IF_          </td>
          <td>(</td>
          <td class="paramtype">N,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HOST_FN,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATE_FN,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COND&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MATE_IF(HOST_FN, MATE_FN, COND)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
It is devised to remedy the issue that some compiler can't generate an unique anonymous variable. In such compiler, user must provide an unique number <em>N</em> to create an unique identifier manually. In other compilers, it is identical to <a class="el" href="mate_8hpp.html#9017d939bd69b57ffa03347874ac607b">MATE_IF()</a> and <em>N</em> is simply ignored.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="mate_8hpp.html#9017d939bd69b57ffa03347874ac607b">MATE_IF()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b64fb21cccc9097c72ddab9f2c37d78a"></a><!-- doxytag: member="mate.hpp::MATE_VOID" ref="b64fb21cccc9097c72ddab9f2c37d78a" args="(MATE_FN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MATE_VOID          </td>
          <td>(</td>
          <td class="paramtype">MATE_FN&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;AM_ANONYMOUS_MATE_VOID(MATE_FN, __LINE__)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an anonymous (unnamed) mate variable which calls the mate function object, <em>MATE_FN</em> in its destructor when it goes out of scope.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="mate_8hpp.html#b96c3730f55e6042664d206492749cf3">AM_ANONYMOUS_MATE_VOID()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c8c88f0150b222ce2afb082872d36918"></a><!-- doxytag: member="mate.hpp::MATE_VOID_" ref="c8c88f0150b222ce2afb082872d36918" args="(N, MATE_FN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MATE_VOID_          </td>
          <td>(</td>
          <td class="paramtype">N,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATE_FN&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MATE_VOID(MATE_FN)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
It is devised to remedy the issue that some compiler can't generate an unique anonymous variable. In such compiler, user must provide an unique number <em>N</em> to create an unique identifier manually. In other compilers, it is identical to <a class="el" href="mate_8hpp.html#b64fb21cccc9097c72ddab9f2c37d78a">MATE_VOID()</a> and <em>N</em> is simply ignored.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="mate_8hpp.html#b64fb21cccc9097c72ddab9f2c37d78a">MATE_VOID()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="becd3ca3f114b18666fd383aad100fef"></a><!-- doxytag: member="mate.hpp::MATE_VOID_IF" ref="becd3ca3f114b18666fd383aad100fef" args="(MATE_FN, COND)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MATE_VOID_IF          </td>
          <td>(</td>
          <td class="paramtype">MATE_FN,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COND&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;AM_ANONYMOUS_MATE_VOID_IF(MATE_FN, COND, __LINE__)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an anonymous (unnamed) mate variable which calls the mate function object, <em>MATE_FN</em> in its destructor when it goes out of scope only if the null-nary predicate, <em>COND</em> asserts true.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="mate_8hpp.html#034dce381d7a40e6b85afa5fc84ed86d">AM_ANONYMOUS_MATE_VOID_IF()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="35d3c430642a21a853b08f966bb16895"></a><!-- doxytag: member="mate.hpp::MATE_VOID_IF_" ref="35d3c430642a21a853b08f966bb16895" args="(N, MATE_FN, COND)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MATE_VOID_IF_          </td>
          <td>(</td>
          <td class="paramtype">N,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATE_FN,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COND&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MATE_VOID_IF(MATE_FN, COND)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
It is devised to remedy the issue that some compiler can't generate an unique anonymous variable. In such compiler, user must provide an unique number <em>N</em> to create an unique identifier manually. In other compilers, it is identical to <a class="el" href="mate_8hpp.html#becd3ca3f114b18666fd383aad100fef">MATE_VOID_IF()</a> and <em>N</em> is simply ignored.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="mate_8hpp.html#becd3ca3f114b18666fd383aad100fef">MATE_VOID_IF()</a> </dd></dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Sat Dec 16 22:27:43 2006 for am::mate by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
