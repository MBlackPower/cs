\section{lambda.hpp File Reference}
\label{lambda_8hpp}\index{lambda.hpp@{lambda.hpp}}
Creating an anonymous function object (pure function). 

\subsection*{Namespaces}
\begin{CompactItemize}
\item 
namespace {\bf am}
\item 
namespace {\bf am::lambda}
\item 
namespace \textbf{am::lambda::detail}
\end{CompactItemize}
\subsection*{Classes}
\begin{CompactItemize}
\item 
struct {\bf am::lambda::detail::lambda\_\-op\_\-tag}
\item 
struct {\bf am::lambda::var\_\-type1}
\item 
struct {\bf am::lambda::var\_\-type1::address\_\-of}
\item 
struct {\bf am::lambda::var\_\-type2}
\item 
struct {\bf am::lambda::var\_\-type2::address\_\-of}
\item 
struct {\bf am::lambda::var\_\-type3}
\item 
struct {\bf am::lambda::var\_\-type3::address\_\-of}
\item 
struct {\bf am::lambda::pf\_\-memdata$<$ P, O, U $>$}
\item 
struct {\bf am::lambda::pf\_\-memdata$<$ P, O, U $>$::address\_\-of}
\item 
struct {\bf am::lambda::condition}
\begin{CompactList}\small\item\em Predicate. \item\end{CompactList}\item 
struct {\bf am::lambda::detail::is\_\-lambda\_\-op$<$ T $>$}
\item 
struct \textbf{am::lambda::detail::if\_\-$<$ true, THEN, ELSE $>$}
\item 
struct \textbf{am::lambda::detail::if\_\-$<$ false, THEN, ELSE $>$}
\item 
struct {\bf am::lambda::detail::lambda\_\-val$<$ V $>$}
\item 
struct {\bf am::lambda::detail::tr$<$ V $>$}
\item 
struct {\bf am::lambda::detail::tr$<$ var\_\-type1 $>$}
\item 
struct {\bf am::lambda::detail::tr$<$ var\_\-type2 $>$}
\item 
struct {\bf am::lambda::detail::tr$<$ var\_\-type3 $>$}
\item 
struct \textbf{am::lambda::detail::void\_\-to\_\-default\_\-void$<$ T $>$}
\item 
struct \textbf{am::lambda::detail::void\_\-to\_\-default\_\-void$<$ void $>$}
\item 
struct \textbf{am::lambda::detail::is\_\-$<$ T $>$}
\item 
struct \textbf{am::lambda::detail::is\_\-$<$ T $>$::\_\-pointer\_\-of\_\-$<$ U $>$}
\item 
struct \textbf{am::lambda::detail::is\_\-$<$ T $>$::\_\-reference\_\-of\_\-$<$ U $>$}
\item 
struct \textbf{am::lambda::detail::binder\_\-impl$<$ R $>$}
\item 
struct \textbf{am::lambda::detail::binder\_\-impl$<$ R $>$::select\_\-return$<$$>$}
\item 
struct \textbf{am::lambda::detail::binder\_\-impl$<$ R $>$::select\_\-return$<$$>$::invoke\_\-on\_\-pointer}
\item 
struct \textbf{am::lambda::detail::binder\_\-impl$<$ R $>$::select\_\-return$<$$>$::invoke\_\-on\_\-object}
\item 
struct {\bf am::lambda::binder\_\-obj0$<$ R, U, A1 $>$}
\item 
struct {\bf am::lambda::binder\_\-const\_\-obj0$<$ R, U, A1 $>$}
\item 
struct {\bf am::lambda::binder\_\-obj1$<$ R, P1, U, A1, A2 $>$}
\item 
struct {\bf am::lambda::binder\_\-const\_\-obj1$<$ R, P1, U, A1, A2 $>$}
\item 
struct {\bf am::lambda::binder\_\-obj2$<$ R, P1, P2, U, A1, A2, A3 $>$}
\item 
struct {\bf am::lambda::binder\_\-const\_\-obj2$<$ R, P1, P2, U, A1, A2, A3 $>$}
\item 
struct {\bf am::lambda::binder\_\-obj3$<$ R, P1, P2, P3, U, A1, A2, A3, A4 $>$}
\item 
struct {\bf am::lambda::binder\_\-const\_\-obj3$<$ R, P1, P2, P3, U, A1, A2, A3, A4 $>$}
\item 
struct {\bf am::lambda::binder0$<$ R $>$}
\item 
struct {\bf am::lambda::binder1$<$ R, P1, A1 $>$}
\item 
struct {\bf am::lambda::binder2$<$ R, P1, P2, A1, A2 $>$}
\item 
struct {\bf am::lambda::binder3$<$ R, P1, P2, P3, A1, A2, A3 $>$}
\end{CompactItemize}
\subsection*{Defines}
\begin{CompactItemize}
\item 
\#define \textbf{\_\-\_\-LAMBDA\_\-HPP\_\-\_\-INCLUDED\_\-\_\-}\label{lambda_8hpp_d07b71d47578d363a02f00922be41cb1}

\item 
\#define {\bf UNARY\_\-BOOL\_\-OP}(NAME, OP)
\item 
\#define {\bf BINARY\_\-BOOL\_\-OP}(NAME, OP)
\end{CompactItemize}
\subsection*{Typedefs}
\begin{CompactItemize}
\item 
typedef void \textbf{am::lambda::detail::default\_\-void}\label{namespaceam_1_1lambda_1_1detail_3b0afad9dbbb6961d3fe3dbf260ae010}

\end{CompactItemize}
\subsection*{Functions}
\begin{CompactItemize}
\item 
template$<$class P, class O, class U$>$ pf\_\-memdata$<$ P, O, U $>$ {\bf am::lambda::operator $\rightarrow$  $\ast$} (P opnd, U(O::$\ast$pu))
\item 
template$<$typename R, typename U, typename A1$>$ binder\_\-obj0$<$ R, U, typename detail::tr$<$ A1 $>$::type $>$ {\bf am::lambda::bind} (R(U::$\ast$mfn)(), A1 a1)
\item 
template$<$typename R, typename P1, typename U, typename A1, typename A2$>$ binder\_\-obj1$<$ R, P1, U, typename detail::tr$<$ A1 $>$::type, typename detail::tr$<$ A2 $>$::type $>$ {\bf am::lambda::bind} (R(U::$\ast$mfn)(P1), A1 a1, A2 a2)
\item 
template$<$typename R, typename P1, typename P2, typename U, typename A1, typename A2, typename A3$>$ binder\_\-obj2$<$ R, P1, P2, U, typename detail::tr$<$ A1 $>$::type, typename detail::tr$<$ A2 $>$::type, typename detail::tr$<$ A3 $>$::type $>$ {\bf am::lambda::bind} (R(U::$\ast$mfn)(P1, P2), A1 a1, A2 a2, A3 a3)
\item 
template$<$typename R, typename P1, typename P2, typename P3, typename U, typename A1, typename A2, typename A3, typename A4$>$ binder\_\-obj3$<$ R, P1, P2, P3, U, typename detail::tr$<$ A1 $>$::type, typename detail::tr$<$ A2 $>$::type, typename detail::tr$<$ A3 $>$::type, typename detail::tr$<$ A4 $>$::type $>$ {\bf am::lambda::bind} (R(U::$\ast$mfn)(P1, P2, P3), A1 a1, A2 a2, A3 a3, A4 a4)
\item 
template$<$typename R$>$ binder0$<$ R $>$ {\bf am::lambda::bind} (R($\ast$fn)())
\item 
template$<$typename R, typename P1, typename A1$>$ binder1$<$ R, P1, typename detail::tr$<$ A1 $>$::type $>$ {\bf am::lambda::bind} (R($\ast$fn)(P1), A1 a1)
\item 
template$<$typename R, typename P1, typename P2, typename A1, typename A2$>$ binder2$<$ R, P1, P2, typename detail::tr$<$ A1 $>$::type, typename detail::tr$<$ A2 $>$::type $>$ {\bf am::lambda::bind} (R($\ast$fn)(P1, P2), A1 a1, A2 a2)
\item 
template$<$typename R, typename P1, typename P2, typename P3, typename A1, typename A2, typename A3$>$ binder3$<$ R, P1, P2, P3, typename detail::tr$<$ A1 $>$::type, typename detail::tr$<$ A2 $>$::type, typename detail::tr$<$ A3 $>$::type $>$ {\bf am::lambda::bind} (R($\ast$fn)(P1, P2, P3), A1 a1, A2 a2, A3 a3)
\end{CompactItemize}
\subsection*{Variables}
\begin{CompactItemize}
\item 
static var\_\-type1 {\bf am::lambda::\_\-1}\label{namespaceam_1_1lambda_46cdab44274e0a15a02179cade2f0bb4}

\begin{CompactList}\small\item\em 1st lambda place holder. \item\end{CompactList}\item 
static var\_\-type2 {\bf am::lambda::\_\-2}\label{namespaceam_1_1lambda_be9e932c0d9cdc2f591c5909be5540f3}

\begin{CompactList}\small\item\em 2nd lambda place holder. \item\end{CompactList}\item 
static var\_\-type3 {\bf am::lambda::\_\-3}\label{namespaceam_1_1lambda_1d4c5fedf2e7cdfc66c96e25990a39a6}

\begin{CompactList}\small\item\em 3rd lambda place holder. \item\end{CompactList}\end{CompactItemize}


\subsection{Detailed Description}
Creating an anonymous function object (pure function). 

\begin{Desc}
\item[Author:]Jae\-Wook Choi (zzzz.ooo \char`\"{}at' gmail.com) \end{Desc}
\begin{Desc}
\item[Version:]1.01 \end{Desc}
\begin{Desc}
\item[Date:]12.12.2006 \end{Desc}
\begin{Desc}
\item[Warning:]This software is provided \char`\"{}as is\char`\"{} without express or implied warranty. 

Use it at your own risk! \end{Desc}


\subsection{Define Documentation}
\index{lambda.hpp@{lambda.hpp}!BINARY_BOOL_OP@{BINARY\_\-BOOL\_\-OP}}
\index{BINARY_BOOL_OP@{BINARY\_\-BOOL\_\-OP}!lambda.hpp@{lambda.hpp}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\#define BINARY\_\-BOOL\_\-OP(NAME, OP)}\label{lambda_8hpp_3705a18f2aa3aec04833a934da1226ac}


\textbf{Value:}

\begin{Code}\begin{verbatim}template<class L, class R> struct NAME : public detail::lambda_op_tag \
{ \
  L lhs_; R rhs_; \
  NAME(L lhs, R rhs) : lhs_( lhs ), rhs_( rhs ) { } \
  template<class T1, class T2, class T3> bool operator ()(T1 t1, T2 t2, T3 t3) const { return lhs_( t1, t2, t3 ) OP rhs_( t1, t2, t3 ); } \
  template<class T1, class T2> bool operator ()(T1 t1, T2 t2) const { return lhs_( t1, t2 ) OP rhs_( t1, t2 ); } \
  template<class T1> bool operator ()(T1 t1) const { return lhs_( t1 ) OP rhs_( t1 ); } \
  bool operator ()() const { return lhs_() OP rhs_(); } \
}; \
template<class L, class R> inline \
NAME<typename detail::tr<L>::type, typename detail::tr<R>::type> \
operator OP(L lhs, R rhs) \
{ \
  typedef typename detail::tr<L>::type lhs_type; \
  typedef typename detail::tr<R>::type rhs_type; \
  return NAME<lhs_type, rhs_type>( lhs_type( lhs ), rhs_type( rhs ) ); \
}
\end{verbatim}\end{Code}
\begin{Desc}
\item[For internal use only.]
Defines a binary boolean lambda operator functor, {\em NAME\/} and its helper operator overloading, {\em OP\/}.



\begin{Code}\begin{verbatim} BINARY_BOOL_OP( pf_eq, == ) 
\end{verbatim}\end{Code}



generates the equivalent code snippet as shown below,



\begin{Code}\begin{verbatim} template<class L, class R> struct pf_eq : public detail::lambda_op_tag
 {
   L lhs_; R rhs_;
   pf_eq(L lhs, R rhs) : lhs_( lhs ), rhs_( rhs ) { }
   template<class T1, class T2, class T3> bool operator ()(T1 t1, T2 t2, T3 t3) const { return lhs_( t1, t2, t3 ) == rhs_( t1, t2, t3 ); }
   template<class T1, class T2> bool operator ()(T1 t1, T2 t2) const { return lhs_( t1, t2 ) == rhs_( t1, t2 ); }
   template<class T1> bool operator ()(T1 t1) const { return lhs_( t1 ) == rhs_( t1 ); }
   bool operator ()() const { return lhs_() == rhs_(); }
 };
 template<class L, class R> inline
 pf_eq<typename detail::tr<L>::type, typename detail::tr<R>::type>
 operator ==(L lhs, R rhs)
 {
   typedef typename detail::tr<L>::type lhs_type;
   typedef typename detail::tr<R>::type rhs_type;
   return pf_eq<lhs_type, rhs_type>( lhs_type( lhs ), rhs_type( rhs ) );
 }
\end{verbatim}\end{Code}

 \end{Desc}
\index{lambda.hpp@{lambda.hpp}!UNARY_BOOL_OP@{UNARY\_\-BOOL\_\-OP}}
\index{UNARY_BOOL_OP@{UNARY\_\-BOOL\_\-OP}!lambda.hpp@{lambda.hpp}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\#define UNARY\_\-BOOL\_\-OP(NAME, OP)}\label{lambda_8hpp_ef5d1af95ba871af311cd9c537d8df73}


\textbf{Value:}

\begin{Code}\begin{verbatim}template<class P> struct NAME : public detail::lambda_op_tag \
{ \
  P opnd_; \
  NAME(P opnd) : opnd_( opnd ) { } \
  template<class T1, class T2, class T3> bool operator ()(T1 t1, T2 t2, T3 t3) const { return OP opnd_( t1, t2, t3 ); } \
  template<class T1, class T2> bool operator ()(T1 t1, T2 t2) const { return OP opnd_( t1, t2 ); } \
  template<class T1> bool operator ()(T1 t1) const { return OP opnd_( t1 ); } \
  bool operator()() const { return OP opnd_(); } \
}; \
template<class P> inline \
NAME<typename detail::tr<P>::type> \
operator OP(P opnd) \
{ \
  typedef typename detail::tr<P>::type opnd_type; \
  return NAME<opnd_type>( opnd_type( opnd ) ); \
}
\end{verbatim}\end{Code}
\begin{Desc}
\item[For internal use only.]
Defines an unary boolean lambda operator functor, {\em NAME\/} and its helper operator overloading, {\em OP\/}.



\begin{Code}\begin{verbatim} UNARY_BOOL_OP( pf_not, ! ) 
\end{verbatim}\end{Code}



generates the equivalent code snippet as shown below,



\begin{Code}\begin{verbatim} template<class P> struct pf_not : public detail::lambda_op_tag
 {
   P opnd_;
   pf_not(P opnd) : opnd_( opnd ) { }
   template<class T1, class T2, class T3> bool operator ()(T1 t1, T2 t2, T3 t3) const { return ! opnd_( t1, t2, t3 ); }
   template<class T1, class T2> bool operator ()(T1 t1, T2 t2) const { return ! opnd_( t1, t2 ); }
   template<class T1> bool operator ()(T1 t1) const { return ! opnd_( t1 ); }
   bool operator ()() const { return ! opnd_(); }
 };
 template<class P> inline
 pf_not<typename detail::tr<P>::type>
 operator !(P opnd)
 {
   typedef typename detail::tr<P>::type opnd_type;
   return pf_not<opnd_type>( opnd_type( opnd ) );
 }
\end{verbatim}\end{Code}

 \end{Desc}
