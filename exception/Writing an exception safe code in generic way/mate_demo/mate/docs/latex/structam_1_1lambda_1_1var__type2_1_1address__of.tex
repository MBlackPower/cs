\section{am::lambda::var\_\-type2::address\_\-of Struct Reference}
\label{structam_1_1lambda_1_1var__type2_1_1address__of}\index{am::lambda::var_type2::address_of@{am::lambda::var\_\-type2::address\_\-of}}
{\tt \#include $<$lambda.hpp$>$}

Inherits {\bf am::lambda::detail::lambda\_\-op\_\-tag}.

Inheritance diagram for am::lambda::var\_\-type2::address\_\-of:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=109pt]{structam_1_1lambda_1_1var__type2_1_1address__of__inherit__graph}
\end{center}
\end{figure}
Collaboration diagram for am::lambda::var\_\-type2::address\_\-of:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=176pt]{structam_1_1lambda_1_1var__type2_1_1address__of__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{CompactItemize}
\item 
\textbf{address\_\-of} ({\bf var\_\-type2} const \&v2)\label{structam_1_1lambda_1_1var__type2_1_1address__of_1a07042e900fca785a9dff2436e0f165}

\item 
template$<$class T1, class T2, class T3$>$ T2 $\ast$ \textbf{operator()} (T1 \&t1, T2 \&t2, T3 \&t3) const \label{structam_1_1lambda_1_1var__type2_1_1address__of_ba6325b1f85eefc0b78f0fc755d6f09b}

\item 
template$<$class T1, class T2$>$ T2 $\ast$ \textbf{operator()} (T1 \&t1, T2 \&t2) const \label{structam_1_1lambda_1_1var__type2_1_1address__of_37ee13dc0b3f453aa7292c62a7a59e67}

\end{CompactItemize}
\subsection*{Public Attributes}
\begin{CompactItemize}
\item 
{\bf var\_\-type2} const \& \textbf{v2\_\-}\label{structam_1_1lambda_1_1var__type2_1_1address__of_9531dcc998c7866c271d1f96744a5ca1}

\end{CompactItemize}


\subsection{Detailed Description}
\begin{Desc}
\item[For internal use only.]
\doxyref{address\_\-of}{p.}{structam_1_1lambda_1_1var__type2_1_1address__of} pure function. Return the address of the variable type 1.

\begin{Desc}
\item[See also:]operator \&() \end{Desc}
\end{Desc}




The documentation for this struct was generated from the following file:\begin{CompactItemize}
\item 
{\bf lambda.hpp}\end{CompactItemize}
