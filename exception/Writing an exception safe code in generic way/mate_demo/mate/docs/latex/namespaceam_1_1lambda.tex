\section{am::lambda Namespace Reference}
\label{namespaceam_1_1lambda}\index{am::lambda@{am::lambda}}
namespace of lambda.  


\subsection*{Classes}
\begin{CompactItemize}
\item 
struct {\bf var\_\-type1}
\item 
struct {\bf var\_\-type2}
\item 
struct {\bf var\_\-type3}
\item 
struct {\bf pf\_\-memdata}
\item 
struct {\bf condition}
\begin{CompactList}\small\item\em Predicate. \item\end{CompactList}\item 
struct {\bf binder\_\-obj0}
\item 
struct {\bf binder\_\-const\_\-obj0}
\item 
struct {\bf binder\_\-obj1}
\item 
struct {\bf binder\_\-const\_\-obj1}
\item 
struct {\bf binder\_\-obj2}
\item 
struct {\bf binder\_\-const\_\-obj2}
\item 
struct {\bf binder\_\-obj3}
\item 
struct {\bf binder\_\-const\_\-obj3}
\item 
struct {\bf binder0}
\item 
struct {\bf binder1}
\item 
struct {\bf binder2}
\item 
struct {\bf binder3}
\end{CompactItemize}
\subsection*{Functions}
\begin{CompactItemize}
\item 
template$<$class P, class O, class U$>$ {\bf pf\_\-memdata}$<$ P, O, U $>$ {\bf operator $\rightarrow$  $\ast$} (P opnd, U(O::$\ast$pu))
\item 
template$<$typename R, typename U, typename A1$>$ {\bf binder\_\-obj0}$<$ R, U, typename {\bf detail::tr}$<$ A1 $>$::type $>$ {\bf bind} (R(U::$\ast$mfn)(), A1 a1)
\item 
template$<$typename R, typename P1, typename U, typename A1, typename A2$>$ {\bf binder\_\-obj1}$<$ R, P1, U, typename {\bf detail::tr}$<$ A1 $>$::type, typename {\bf detail::tr}$<$ A2 $>$::type $>$ {\bf bind} (R(U::$\ast$mfn)(P1), A1 a1, A2 a2)
\item 
template$<$typename R, typename P1, typename P2, typename U, typename A1, typename A2, typename A3$>$ {\bf binder\_\-obj2}$<$ R, P1, P2, U, typename {\bf detail::tr}$<$ A1 $>$::type, typename {\bf detail::tr}$<$ A2 $>$::type, typename {\bf detail::tr}$<$ A3 $>$::type $>$ {\bf bind} (R(U::$\ast$mfn)(P1, P2), A1 a1, A2 a2, A3 a3)
\item 
template$<$typename R, typename P1, typename P2, typename P3, typename U, typename A1, typename A2, typename A3, typename A4$>$ {\bf binder\_\-obj3}$<$ R, P1, P2, P3, U, typename {\bf detail::tr}$<$ A1 $>$::type, typename {\bf detail::tr}$<$ A2 $>$::type, typename {\bf detail::tr}$<$ A3 $>$::type, typename {\bf detail::tr}$<$ A4 $>$::type $>$ {\bf bind} (R(U::$\ast$mfn)(P1, P2, P3), A1 a1, A2 a2, A3 a3, A4 a4)
\item 
template$<$typename R$>$ {\bf binder0}$<$ R $>$ {\bf bind} (R($\ast$fn)())
\item 
template$<$typename R, typename P1, typename A1$>$ {\bf binder1}$<$ R, P1, typename {\bf detail::tr}$<$ A1 $>$::type $>$ {\bf bind} (R($\ast$fn)(P1), A1 a1)
\item 
template$<$typename R, typename P1, typename P2, typename A1, typename A2$>$ {\bf binder2}$<$ R, P1, P2, typename {\bf detail::tr}$<$ A1 $>$::type, typename {\bf detail::tr}$<$ A2 $>$::type $>$ {\bf bind} (R($\ast$fn)(P1, P2), A1 a1, A2 a2)
\item 
template$<$typename R, typename P1, typename P2, typename P3, typename A1, typename A2, typename A3$>$ {\bf binder3}$<$ R, P1, P2, P3, typename {\bf detail::tr}$<$ A1 $>$::type, typename {\bf detail::tr}$<$ A2 $>$::type, typename {\bf detail::tr}$<$ A3 $>$::type $>$ {\bf bind} (R($\ast$fn)(P1, P2, P3), A1 a1, A2 a2, A3 a3)
\end{CompactItemize}
\subsection*{Variables}
\begin{CompactItemize}
\item 
static {\bf var\_\-type1} {\bf \_\-1}\label{namespaceam_1_1lambda_46cdab44274e0a15a02179cade2f0bb4}

\begin{CompactList}\small\item\em 1st lambda place holder. \item\end{CompactList}\item 
static {\bf var\_\-type2} {\bf \_\-2}\label{namespaceam_1_1lambda_be9e932c0d9cdc2f591c5909be5540f3}

\begin{CompactList}\small\item\em 2nd lambda place holder. \item\end{CompactList}\item 
static {\bf var\_\-type3} {\bf \_\-3}\label{namespaceam_1_1lambda_1d4c5fedf2e7cdfc66c96e25990a39a6}

\begin{CompactList}\small\item\em 3rd lambda place holder. \item\end{CompactList}\end{CompactItemize}


\subsection{Detailed Description}
namespace of lambda. 

Defines simple set of boolean lambda operations and member data pointer access.

It only supports a set of boolean lambda operations as listed below:\begin{enumerate}
\item unary boolean operator : !\item binary boolean operator : ==, !=, $<$, $>$, $<$=, $>$=, \&\&, $|$$|$\end{enumerate}


and member data pointer access: ($\ast$$\ast$$\ast$ Read only access ! $\ast$$\ast$$\ast$)\begin{enumerate}
\item unary operator : var\_\-type1::operator \&()\item binary operator : -$>$$\ast$\end{enumerate}


Supports 3 lambda place holder: \doxyref{am::lambda::\_\-1}{p.}{namespaceam_1_1lambda_46cdab44274e0a15a02179cade2f0bb4}, \doxyref{am::lambda::\_\-2}{p.}{namespaceam_1_1lambda_be9e932c0d9cdc2f591c5909be5540f3}, \doxyref{am::lambda::\_\-3}{p.}{namespaceam_1_1lambda_1d4c5fedf2e7cdfc66c96e25990a39a6}

Binding free function or member function up to 3 arguments supports to collaborate with the lambda place holder. 



\subsection{Function Documentation}
\index{am::lambda@{am::lambda}!bind@{bind}}
\index{bind@{bind}!am::lambda@{am::lambda}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}template$<$typename R, typename P1, typename P2, typename P3, typename A1, typename A2, typename A3$>$ {\bf binder3}$<$R, P1, P2, P3, typename {\bf detail::tr}$<$A1$>$::type, typename {\bf detail::tr}$<$A2$>$::type, typename {\bf detail::tr}$<$A3$>$::type $>$ am::lambda::bind (R($\ast$)(P1, P2, P3) {\em fn}, A1 {\em a1}, A2 {\em a2}, A3 {\em a3})\hspace{0.3cm}{\tt  [inline]}}\label{namespaceam_1_1lambda_20a90f4c05b8c818115c133bf88d0dcd}


Bind the free function with three specified input arguments.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em fn}]Specifies the free function pointer which takes three input arguments and return {\em R\/} type \item[\mbox{$\leftarrow$} {\em a1}]Specifies the first input augment. \item[\mbox{$\leftarrow$} {\em a2}]Specifies the second input augment. \item[\mbox{$\leftarrow$} {\em a3}]Specifies the third input augment. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Function object which calls the specified free function with three specified input arguments.\end{Desc}
\begin{Desc}
\item[See also:]\doxyref{binder3}{p.}{structam_1_1lambda_1_1binder3} \end{Desc}
\index{am::lambda@{am::lambda}!bind@{bind}}
\index{bind@{bind}!am::lambda@{am::lambda}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}template$<$typename R, typename P1, typename P2, typename A1, typename A2$>$ {\bf binder2}$<$R, P1, P2, typename {\bf detail::tr}$<$A1$>$::type, typename {\bf detail::tr}$<$A2$>$::type $>$ am::lambda::bind (R($\ast$)(P1, P2) {\em fn}, A1 {\em a1}, A2 {\em a2})\hspace{0.3cm}{\tt  [inline]}}\label{namespaceam_1_1lambda_948369db441f2c2a8ae58372b0b52a48}


Bind the free function with two specified input arguments.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em fn}]Specifies the free function pointer which takes two input arguments and return {\em R\/} type \item[\mbox{$\leftarrow$} {\em a1}]Specifies the first input augment. \item[\mbox{$\leftarrow$} {\em a2}]Specifies the second input augment. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Function object which calls the specified free function with two specified input arguments.\end{Desc}
\begin{Desc}
\item[See also:]\doxyref{binder2}{p.}{structam_1_1lambda_1_1binder2} \end{Desc}
\index{am::lambda@{am::lambda}!bind@{bind}}
\index{bind@{bind}!am::lambda@{am::lambda}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}template$<$typename R, typename P1, typename A1$>$ {\bf binder1}$<$R, P1, typename {\bf detail::tr}$<$A1$>$::type $>$ am::lambda::bind (R($\ast$)(P1) {\em fn}, A1 {\em a1})\hspace{0.3cm}{\tt  [inline]}}\label{namespaceam_1_1lambda_c1273940aecef0a155765fa8c51fd8db}


Bind the free function with a specified input argument.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em fn}]Specifies the free function pointer which takes an input argument and return {\em R\/} type \item[\mbox{$\leftarrow$} {\em a1}]Specifies the first input augment. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Function object which calls the specified free function with the specified input argument.\end{Desc}
\begin{Desc}
\item[See also:]\doxyref{binder1}{p.}{structam_1_1lambda_1_1binder1} \end{Desc}
\index{am::lambda@{am::lambda}!bind@{bind}}
\index{bind@{bind}!am::lambda@{am::lambda}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}template$<$typename R$>$ {\bf binder0}$<$R$>$ am::lambda::bind (R($\ast$)() {\em fn})\hspace{0.3cm}{\tt  [inline]}}\label{namespaceam_1_1lambda_00f5bfc80d71881117c83cd7bea8557f}


Bind the free function with no input argument.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em fn}]Specifies the free function pointer which takes no input argument and return {\em R\/} type \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Function object which calls the specified free function.\end{Desc}
\begin{Desc}
\item[See also:]\doxyref{binder0}{p.}{structam_1_1lambda_1_1binder0} \end{Desc}
\index{am::lambda@{am::lambda}!bind@{bind}}
\index{bind@{bind}!am::lambda@{am::lambda}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}template$<$typename R, typename P1, typename P2, typename P3, typename U, typename A1, typename A2, typename A3, typename A4$>$ {\bf binder\_\-const\_\-obj3}$<$ R, P1, P2, P3, U, typename {\bf detail::tr}$<$ A1 $>$::type, typename {\bf detail::tr}$<$ A2 $>$::type, typename {\bf detail::tr}$<$ A3 $>$::type, typename {\bf detail::tr}$<$ A4 $>$::type $>$ am::lambda::bind (R(U::$\ast$)(P1, P2, P3) {\em mfn}, A1 {\em a1}, A2 {\em a2}, A3 {\em a3}, A4 {\em a4})\hspace{0.3cm}{\tt  [inline]}}\label{namespaceam_1_1lambda_8aed6d48145e0dab7c856a97865069c2}


Bind the member function with the object on which the function call is made and with three specified input arguments.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em mfn}]Specifies the member function pointer which takes three input arguments and return {\em R\/} type \item[\mbox{$\leftarrow$} {\em a1}]Specifies the object on which the function call is made. \item[\mbox{$\leftarrow$} {\em a2}]Specifies the first input augment. \item[\mbox{$\leftarrow$} {\em a3}]Specifies the second input augment. \item[\mbox{$\leftarrow$} {\em a4}]Specifies the third input augment. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Function object which calls the specified member function on the specified bound object with the specified input arguments.\end{Desc}
\begin{Desc}
\item[See also:]\doxyref{binder\_\-obj3}{p.}{structam_1_1lambda_1_1binder__obj3} \end{Desc}
\index{am::lambda@{am::lambda}!bind@{bind}}
\index{bind@{bind}!am::lambda@{am::lambda}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}template$<$typename R, typename P1, typename P2, typename U, typename A1, typename A2, typename A3$>$ {\bf binder\_\-const\_\-obj2}$<$ R, P1, P2, U, typename {\bf detail::tr}$<$ A1 $>$::type, typename {\bf detail::tr}$<$ A2 $>$::type, typename {\bf detail::tr}$<$ A3 $>$::type $>$ am::lambda::bind (R(U::$\ast$)(P1, P2) {\em mfn}, A1 {\em a1}, A2 {\em a2}, A3 {\em a3})\hspace{0.3cm}{\tt  [inline]}}\label{namespaceam_1_1lambda_1299fd6e21110372d5e88259d8e7f284}


Bind the member function with the object on which the function call is made and with two specified input arguments.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em mfn}]Specifies the member function pointer which takes two input arguments and return {\em R\/} type \item[\mbox{$\leftarrow$} {\em a1}]Specifies the object on which the function call is made. \item[\mbox{$\leftarrow$} {\em a2}]Specifies the first input augment. \item[\mbox{$\leftarrow$} {\em a3}]Specifies the second input augment. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Function object which calls the specified member function on the specified bound object with the specified input arguments.\end{Desc}
\begin{Desc}
\item[See also:]\doxyref{binder\_\-obj2}{p.}{structam_1_1lambda_1_1binder__obj2} \end{Desc}
\index{am::lambda@{am::lambda}!bind@{bind}}
\index{bind@{bind}!am::lambda@{am::lambda}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}template$<$typename R, typename P1, typename U, typename A1, typename A2$>$ {\bf binder\_\-const\_\-obj1}$<$ R, P1, U, typename {\bf detail::tr}$<$ A1 $>$::type, typename {\bf detail::tr}$<$ A2 $>$::type $>$ am::lambda::bind (R(U::$\ast$)(P1) {\em mfn}, A1 {\em a1}, A2 {\em a2})\hspace{0.3cm}{\tt  [inline]}}\label{namespaceam_1_1lambda_161cf36bbb18b203acc4f19c0ee7d800}


Bind the member function with the object on which the function call is made and with a specified input argument.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em mfn}]Specifies the member function pointer which takes an input parameter and return {\em R\/} type \item[\mbox{$\leftarrow$} {\em a1}]Specifies the object on which the function call is made. \item[\mbox{$\leftarrow$} {\em a2}]Specifies the first input augment. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Function object which calls the specified member function on the specified bound object with the specified input argument.\end{Desc}
\begin{Desc}
\item[See also:]\doxyref{binder\_\-obj1}{p.}{structam_1_1lambda_1_1binder__obj1} \end{Desc}
\index{am::lambda@{am::lambda}!bind@{bind}}
\index{bind@{bind}!am::lambda@{am::lambda}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}template$<$typename R, typename U, typename A1$>$ {\bf binder\_\-const\_\-obj0}$<$ R, U, typename {\bf detail::tr}$<$ A1 $>$::type $>$ am::lambda::bind (R(U::$\ast$)() {\em mfn}, A1 {\em a1})\hspace{0.3cm}{\tt  [inline]}}\label{namespaceam_1_1lambda_794d3c4a2b7231c36cfc0684fea9bf5e}


Bind the member function with the object on which the function call is made.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[\mbox{$\leftarrow$} {\em mfn}]Specifies the member function pointer which takes no input parameter and return {\em R\/} type \item[\mbox{$\leftarrow$} {\em a1}]Specifies the object on which the function call is made. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Function object which calls the specified member function on the specified bound object.\end{Desc}
\begin{Desc}
\item[See also:]\doxyref{binder\_\-obj0}{p.}{structam_1_1lambda_1_1binder__obj0} \end{Desc}
\index{am::lambda@{am::lambda}!operator-> *@{operator-$>$ $\ast$}}
\index{operator-> *@{operator-$>$ $\ast$}!am::lambda@{am::lambda}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}template$<$class P, class O, class U$>$ {\bf pf\_\-memdata}$<$P, O, U$>$ am::lambda::operator $\rightarrow$  $\ast$ (P {\em opnd}, U O::$\ast$ {\em pu})\hspace{0.3cm}{\tt  [inline]}}\label{namespaceam_1_1lambda_0cd88bb91100652d753cb4af51de47a3}


\begin{Desc}
\item[For internal use only.]
-$>$$\ast$ operator overloading. Helper fucntion for \doxyref{pf\_\-memdata}{p.}{structam_1_1lambda_1_1pf__memdata}.



\begin{Code}\begin{verbatim} struct MyData
 {
   int id;
   std::string msg;
 };

 MyData InitMyData(int id, std::string msg)
 {
   MyData md; md.id = id; md.msg = msg;
   return md;
 }

 void main()
 {
   std::vector<MyData> myDataVec;

   myDataVec.push_back( InitMyData( 1, "hello" ) );
   myDataVec.push_back( InitMyData( 2, "world!" ) );

   std::vector<MyData>::iterator it_f = std::find_if( myDataVec.begin(), myDataVec.end(),
     &am::lambda::_1->*&MyData::id == 2 ); // Find the iterator of the element whose id is 2.
   assert( it_f != myDataVec.end() );

   std::cout << it_f->msg.c_str() << std::endl;  // Print out "world!"

   std::pair<float, MyData> myPair = std::make_pair( 1.2f, InitMyData( 3, "lambda!" ) );

   bool ret1 = ( &( &am::lambda::_1->*&std::pair<float, MyData>::second )->*&MyData::id == 3 )( myPair );
   assert( true == ret1 );

   bool ret2 = ( &( am::lambda::_1->*&std::pair<float, MyData>::second )->*&MyData::id == 3 )( &myPair );
   assert( true == ret2 );
 }
\end{verbatim}\end{Code}

 \end{Desc}
