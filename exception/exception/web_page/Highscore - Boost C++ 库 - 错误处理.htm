<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0051)http://zh.highscore.de/cpp/boost/errorhandling.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Highscore - Boost C++ 库 - 错误处理</title>
<link rel="stylesheet" href="./Highscore - Boost C++ 库 - 错误处理_files/highscore.css" type="text/css">
<link rev="made" href="mailto:boris@highscore.de">
<link rel="home" href="http://zh.highscore.de/cpp/boost/frontpage.html" title="Boost C++ 库">
<link rel="up" href="http://zh.highscore.de/cpp/boost/frontpage.html" title="Boost C++ 库">
<link rel="prev" href="http://zh.highscore.de/cpp/boost/datastructures.html" title="第 14 章 数据结构">
<link rel="next" href="http://zh.highscore.de/cpp/boost/castoperators.html" title="第 16 章 类型转换操作符">
<link rel="chapter" href="http://zh.highscore.de/cpp/boost/introduction.html" title="第 1 章 简介">
<link rel="chapter" href="http://zh.highscore.de/cpp/boost/smartpointers.html" title="第 2 章 智能指针">
<link rel="chapter" href="http://zh.highscore.de/cpp/boost/functionobjects.html" title="第 3 章 函数对象">
<link rel="chapter" href="http://zh.highscore.de/cpp/boost/eventhandling.html" title="第 4 章 事件处理">
<link rel="chapter" href="http://zh.highscore.de/cpp/boost/stringhandling.html" title="第 5 章 字符串处理">
<link rel="chapter" href="http://zh.highscore.de/cpp/boost/multithreading.html" title="第 6 章 多线程">
<link rel="chapter" href="http://zh.highscore.de/cpp/boost/asio.html" title="第 7 章 异步输入输出">
<link rel="chapter" href="http://zh.highscore.de/cpp/boost/interprocesscommunication.html" title="第 8 章 进程间通讯">
<link rel="chapter" href="http://zh.highscore.de/cpp/boost/filesystem.html" title="第 9 章 文件系统">
<link rel="chapter" href="http://zh.highscore.de/cpp/boost/datetime.html" title="第 10 章 日期与时间">
<link rel="chapter" href="http://zh.highscore.de/cpp/boost/serialization.html" title="第 11 章 序列化">
<link rel="chapter" href="http://zh.highscore.de/cpp/boost/parser.html" title="第 12 章 词法分析器">
<link rel="chapter" href="http://zh.highscore.de/cpp/boost/containers.html" title="第 13 章 容器">
<link rel="chapter" href="http://zh.highscore.de/cpp/boost/datastructures.html" title="第 14 章 数据结构">
<link rel="chapter" href="./Highscore - Boost C++ 库 - 错误处理_files/Highscore - Boost C++ 库 - 错误处理.htm" title="第 15 章 错误处理">
<link rel="chapter" href="http://zh.highscore.de/cpp/boost/castoperators.html" title="第 16 章 类型转换操作符">
<link rel="section" href="http://zh.highscore.de/cpp/boost/errorhandling.html#errorhandling_general" title="15.1. 概述">
<link rel="section" href="http://zh.highscore.de/cpp/boost/errorhandling.html#errorhandling_system" title="15.2. Boost.System">
<link rel="section" href="http://zh.highscore.de/cpp/boost/errorhandling.html#errorhandling_exception" title="15.3. Boost.Exception">
<meta http-equiv="pics-label" content="(pics-1.1 &quot;http://www.icra.org/ratingsv02.html&quot; l gen true for &quot;http://www.highscore.de&quot; r (nz 1 vz 1 lz 1 oz 1 cz 1) gen true for &quot;http://highscore.de&quot; r (nz 1 vz 1 lz 1 oz 1 cz 1))">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<link href="http://www.highscore.de/favicon.ico" rel="shortcut icon" type="image/vnd.microsoft.icon">
<script type="text/javascript" src="chrome-extension://bfbmjmiodbnnpllbbbfblcplfjjepjdn/js/injected.js"></script></head>
<body>
<div lang="zh" class="docbook chapter" title="第 15 章 错误处理">
<p class="title">Boost C++ 库</p>
<script type="text/javascript">
          var titlepage = "导言";
        
      var titles = new Array(titlepage,
      
        "第 1 章 简介",
      
        "第 2 章 智能指针",
      
        "第 3 章 函数对象",
      
        "第 4 章 事件处理",
      
        "第 5 章 字符串处理",
      
        "第 6 章 多线程",
      
        "第 7 章 异步输入输出",
      
        "第 8 章 进程间通讯",
      
        "第 9 章 文件系统",
      
        "第 10 章 日期与时间",
      
        "第 11 章 序列化",
      
        "第 12 章 词法分析器",
      
        "第 13 章 容器",
      
        "第 14 章 数据结构",
      
        "第 15 章 错误处理",
      
        "第 16 章 类型转换操作符",
      
      "");

      
          var titlehtml = "frontpage.html";
        
      var filenames = new Array(titlehtml,
      
        "introduction.html",
      
        "smartpointers.html",
      
        "functionobjects.html",
      
        "eventhandling.html",
      
        "stringhandling.html",
      
        "multithreading.html",
      
        "asio.html",
      
        "interprocesscommunication.html",
      
        "filesystem.html",
      
        "datetime.html",
      
        "serialization.html",
      
        "parser.html",
      
        "containers.html",
      
        "datastructures.html",
      
        "errorhandling.html",
      
        "castoperators.html",
      
      "");

      
      document.open();
      document.write('<form action="" class="toc">');
      document.write('<select size="1" onchange="location.href=options[selectedIndex].value">');
      for (var i = 0; i < titles.length && i < filenames.length; ++i) {
        if (titles[i] != "" && filenames[i] != "") {
          document.write('<option');
          document.write(' value="' + filenames[i] + '"');
          var expr = new RegExp('[/\]' + filenames[i] + '$');
          if (expr.test(location.href)) {
            document.write(' selected="selected"');
          }
          document.write('>' + titles[i] + '<\/option>');
        }
      }
      document.write('<\/select>');
      document.write('<\/form>');
      document.close();
      
    </script><form action="" class="toc"><select size="1" onchange="location.href=options[selectedIndex].value"><option value="frontpage.html">导言</option><option value="introduction.html">第&nbsp;1&nbsp;章&nbsp;简介</option><option value="smartpointers.html">第&nbsp;2&nbsp;章&nbsp;智能指针</option><option value="functionobjects.html">第&nbsp;3&nbsp;章&nbsp;函数对象</option><option value="eventhandling.html">第&nbsp;4&nbsp;章&nbsp;事件处理</option><option value="stringhandling.html">第&nbsp;5&nbsp;章&nbsp;字符串处理</option><option value="multithreading.html">第&nbsp;6&nbsp;章&nbsp;多线程</option><option value="asio.html">第&nbsp;7&nbsp;章&nbsp;异步输入输出</option><option value="interprocesscommunication.html">第&nbsp;8&nbsp;章&nbsp;进程间通讯</option><option value="filesystem.html">第&nbsp;9&nbsp;章&nbsp;文件系统</option><option value="datetime.html">第&nbsp;10&nbsp;章&nbsp;日期与时间</option><option value="serialization.html">第&nbsp;11&nbsp;章&nbsp;序列化</option><option value="parser.html">第&nbsp;12&nbsp;章&nbsp;词法分析器</option><option value="containers.html">第&nbsp;13&nbsp;章&nbsp;容器</option><option value="datastructures.html">第&nbsp;14&nbsp;章&nbsp;数据结构</option><option value="errorhandling.html" selected="selected">第&nbsp;15&nbsp;章&nbsp;错误处理</option><option value="castoperators.html">第&nbsp;16&nbsp;章&nbsp;类型转换操作符</option></select></form><noscript>&lt;p class="toc"&gt;&lt;a href="toc.html"&gt;目录&lt;/a&gt;&lt;/p&gt;</noscript>
<hr class="hrhead">
<h1 class="title">
<a name="errorhandling"></a>第&nbsp;15&nbsp;章&nbsp;错误处理</h1>
<hr>
<div class="toc">
<h3>目录</h3>
<ul>
<li><span class="sect1"><a href="http://zh.highscore.de/cpp/boost/errorhandling.html#errorhandling_general">15.1 概述</a></span></li>
<li><span class="sect1"><a href="http://zh.highscore.de/cpp/boost/errorhandling.html#errorhandling_system">15.2 Boost.System</a></span></li>
<li><span class="sect1"><a href="http://zh.highscore.de/cpp/boost/errorhandling.html#errorhandling_exception">15.3 Boost.Exception</a></span></li>
</ul>
</div>
<p class="license"><a href="http://creativecommons.org/licenses/by-nc-nd/3.0/de/deed.zh" rel="license" target="_top"><img src="./Highscore - Boost C++ 库 - 错误处理_files/88x31_cc_logo.gif" alt="" width="88" height="31"></a> 该书采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/de/deed.zh" rel="license" target="_top">Creative Commons License</a> 授权</p>
<p class="paperbook"><img src="./Highscore - Boost C++ 库 - 错误处理_files/boost-cover-front-88x125.png" alt="" width="88" height="125" style="margin-right:5px">A new edition of this book is available! It has been published as a print book and can be bought from <a target="_top" href="http://www.barnesandnoble.com/w/the-boost-c-libraries-boris-sch-ling/1104526142">Barnes and Noble</a>, <a target="_top" href="http://www.amazon.com/gp/product/0982219199">Amazon</a> and other bookstores. The new edition is up-to-date and based on the Boost C++ Libraries 1.47.0 (released in July 2011). Several chapters have been updated (for example to Boost.Spirit 2.x, Boost.Signals 2 and Boost.Filesystem 3) and many new libraries are covered (for example Boost.CircularBuffer, Boost.Intrusive and Boost.MultiArray). For more information please see the publisher's website <a target="_top" href="http://xmlpress.net/publications/boost">XML Press</a>.</p>
<hr>
<h2 class="title">
<a name="errorhandling_general"></a>15.1.&nbsp;概述</h2>
<div class="sect1">
<p>在执行时会有潜在失败可能的每个函数都需要一种合适的方式和它的调用者进行交互。 在C++中，这一步是通过返回值或抛出一个异常来完成的。
    作为常识，返回值经常用在处理非错误的异常中。 调用者通过返回值作出相应的反馈。</p>
<p>异常被通常用来标示出未预期的异常情况。 一个很好的例子是在错误的使用 <code class="code">new</code>
    时将抛出的一个动态内存分配异常类型 <code class="exceptionname">std::bad_alloc</code> 。
    由于内存的分配通常不会出现任何问题，如果总是检查返回值将会变得异常累赘。</p>
<p>本章介绍了两种可以帮助开发者利用错误处理的Boost C++库：其中 Boost.System
    可以由特定操作系统平台的错误代码转换出跨平台的错误代码。 借助于
    Boost.System，函数基于某个特定操作系统的返回值类型可以被转换成为跨平台的类型。 另外，Boost.Exception
    允许给任何异常添加额外的信息，以便利用 <code class="code">catch</code> 相应的处理程序更好的对异常作出反应。</p>
</div>
<hr>
<h2 class="title">
<a name="errorhandling_system"></a>15.2.&nbsp;Boost.System</h2>
<div class="sect1">
<p><a class="link" href="http://www.boost.org/libs/system/">Boost.System</a>
    是一个定义了四个类的小型库，用以识别错误。 <code class="classname">boost::system::error_code</code>
    是一个最基本的类，用于代表某个特定操作系统的异常。
    由于操作系统通常枚举异常，<code class="classname">boost::system::error_code</code>
    中以变量的形式保存错误代码 <code class="code">int</code>。 下面的例子说明了如何通过访问 Boost.Asio 类来使用这个类。</p>
<pre class="programlisting">#include &lt;boost/system/error_code.hpp&gt; 
#include &lt;boost/asio.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;string&gt; 

int main() 
{ 
  boost::system::error_code ec; 
  std::string hostname = boost::asio::ip::host_name(ec); 
  std::cout &lt;&lt; ec.value() &lt;&lt; std::endl; 
} </pre>
<ul class="programlisting"><li><a class="programlisting" href="http://zh.highscore.de/cpp/boost/src/15.2.1/main.cpp">下载源代码</a></li></ul>
<p>Boost.Asio 提供了独立的函数 <code class="function">boost::asio::ip::host_name()</code>
    可以返回正在执行的应用程序名。</p>
<p><code class="classname">boost::system::error_code</code> 类型的一个对象可以作为单独的参数传递给
    <code class="function">boost::asio::ip::host_name()</code>。 如果当前的操作系统函数失败，
    这个参数包含相关的错误代码。 也可以通过调用 <code class="function">boost::asio::ip::host_name()</code>
    而不使用任何参数，以防止错误代码是非相关的。</p>
<p>事实上在Boost 1.36.0中 <code class="function">boost::asio::ip::host_name()</code>
    是有问题的，然而它可以当作一个很好的例子。 即使当前操作系统函数成功返回了计算机名，这个函数它也可能返回一个错误代码。 由于在Boost
    1.37.0中解决了这个问题，现在可以放心使用 <code class="function">boost::asio::ip::host_name()</code>
    了。</p>
<p>由于错误代码仅仅是一个数值，因此可以借助于 <code class="methodname">value()</code> 方法得到它。
    由于错误代码0通常意味着没有错误，其他的值的意义则依赖于操作系统并且需要查看相关手册。</p>
<p>如果使用Boost 1.36.0， 并且用Visual Studio 2008在Windows
    XP环境下编译以上应用程序将不断产生错误代码14（没有足够的存储空间以完成操作）。 即使函数
    <code class="function">boost::asio::ip::host_name()</code> 成功决定了计算机名，也会报出错误代码14。
    事实上这是因为函数 <code class="function">boost::asio::ip::host_name()</code> 的实现有问题。</p>
<p>除了 <code class="methodname">value()</code> 方法之外, 类
    <code class="classname">boost::system::error_code</code> 提供了方法
    <code class="methodname">category()</code>。 这个方法可返回一个在 Boost.System 中定义的二级对象:
    <code class="classname">boost::system::category</code>。</p>
<p>错误代码是简单的数值。 操作系统开发商，例如微软，可以保证系统错误代码的特异性。
    对于任何开发商来说，在所有现有应用程序中保持错误代码的独一无二是几乎不可能的。
    他需要一个包含有所有软件开发者的错误代码中心数据库，以防止在不同的方案下重复使用相同的代码。 当然这是不实际的。
    这是错误分类表存在的缘由。</p>
<p>类型 <code class="classname">boost::system::error_code</code> 的错误代码总是属于可以使用
    <code class="methodname">category()</code> 方法获取的分类。 通过预定义的对象
    <var>boost::system::system_category</var> 来表示操作系统的错误。</p>
<p>通过调用 <code class="methodname">category()</code> 方法，可以返回预定义变量
    <var>boost::system::system_category</var> 的一个引用。 它允许获取关于分类的特定信息。
    例如在使用的是 system 分类的情况下，通过使用 <code class="methodname">name()</code> 方法将得到它的名字
    <code class="computeroutput">system</code>。</p>
<pre class="programlisting">#include &lt;boost/system/error_code.hpp&gt; 
#include &lt;boost/asio.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;string&gt; 

int main() 
{ 
  boost::system::error_code ec; 
  std::string hostname = boost::asio::ip::host_name(ec); 
  std::cout &lt;&lt; ec.value() &lt;&lt; std::endl; 
  std::cout &lt;&lt; ec.category().name() &lt;&lt; std::endl; 
} </pre>
<ul class="programlisting"><li><a class="programlisting" href="http://zh.highscore.de/cpp/boost/src/15.2.2/main.cpp">下载源代码</a></li></ul>
<p>通过错误代码和错误分类识别出的错误是独一无二的。
    由于仅仅在错误分类中的错误代码是必须唯一的，程序员应当在希望定义某个特定应用程序的错误代码时创建一个新的分类。
    这使得任何错误代码都不会影响到其他开发者的错误代码。</p>
<pre class="programlisting">#include &lt;boost/system/error_code.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;string&gt; 

class application_category : 
  public boost::system::error_category 
{ 
public: 
  const char *name() const { return "application"; } 
  std::string message(int ev) const { return "error message"; } 
}; 

application_category cat; 

int main() 
{ 
  boost::system::error_code ec(14, cat); 
  std::cout &lt;&lt; ec.value() &lt;&lt; std::endl; 
  std::cout &lt;&lt; ec.category().name() &lt;&lt; std::endl; 
} </pre>
<ul class="programlisting"><li><a class="programlisting" href="http://zh.highscore.de/cpp/boost/src/15.2.3/main.cpp">下载源代码</a></li></ul>
<p>通过创建一个派生于 <code class="classname">boost::system::error_category</code>
    的类以及实现作为新分类的所必须的接口的不同方法可以定义一个新的错误分类。 由于方法 <code class="methodname">name()</code> 和
    <code class="methodname">message()</code> 在类
    <code class="classname">boost::system::error_category</code>
    中被定义为纯虚拟函数，所以它们是必须提供的。 至于额外的方法，在必要的条件下，可以重载相对应的默认行为。</p>
<p>当方法 <code class="methodname">name()</code> 返回错误分类名时，可以使用方法
    <code class="methodname">message()</code> 来获取针对某个错误代码的描述。 不像之前的那个例子，参数
    <var>ev</var> 往往被用于返回基于错误代码的描述。</p>
<p>新创建的错误分类的对象可以被用来初始化相应的错误代码。 本例中定义了一个用于新分类
    <code class="classname">application_category</code> 的错误代码 <var>ec</var> 。
    然而错误代码14不再是系统错误；他的意义被开发者指定为新的错误分类。</p>
<p><code class="classname">boost::system::error_code</code> 包含了一个叫作
    <code class="methodname">default_error_condition()</code> 的方法，它可以返回
    <code class="classname">boost::system::error_condition</code>类型的对象。
    <code class="classname">boost::system::error_condition</code> 的接口几乎与
    <code class="classname">boost::system::error_code</code> 相同。 唯一的差别是只有类
    <code class="classname">boost::system::error_code</code> 提供了方法
    <code class="methodname">default_error_condition()</code> 。</p>
<pre class="programlisting">#include &lt;boost/system/error_code.hpp&gt; 
#include &lt;boost/asio.hpp&gt; 
#include &lt;iostream&gt; 
#include &lt;string&gt; 

int main() 
{ 
  boost::system::error_code ec; 
  std::string hostname = boost::asio::ip::host_name(ec); 
  boost::system::error_condition ecnd = ec.default_error_condition(); 
  std::cout &lt;&lt; ecnd.value() &lt;&lt; std::endl; 
  std::cout &lt;&lt; ecnd.category().name() &lt;&lt; std::endl; 
} </pre>
<ul class="programlisting"><li><a class="programlisting" href="http://zh.highscore.de/cpp/boost/src/15.2.4/main.cpp">下载源代码</a></li></ul>
<p><code class="classname">boost::system::error_condition</code> 的使用方法与
    <code class="classname">boost::system::error_code</code> 类似。
    对象<code class="classname">boost::system::error_condition</code> 的
    <code class="methodname">value()</code> 和 <code class="methodname">category()</code>
    方法都可以像上面的例子中那样调用。</p>
<p>有或多或少两个相同的类的原因很简单：当类
    <code class="classname">boost::system::error_code</code> 被当作当前平台的错误代码时， 类
    <code class="classname">boost::system::error_condition</code> 可以被用作获取跨平台的错误代码。
    通过调用 <code class="methodname">default_error_condition()</code>
    方法，可以把依赖于某个平台的的错误代码转换成
    <code class="classname">boost::system::error_condition</code> 类型的跨平台的错误代码。</p>
<p>如果执行以上应用程序，它将显示数字12以及错误分类 <code class="computeroutput">GENERIC</code>。
    依赖于平台的错误代码14被转换成了跨平台的错误代码12。 借助于
    <code class="classname">boost::system::error_condition</code>
    ，可以总是使用相同的数字表示错误，无视当前操作系统。 当Windows报出错误14时，其他操作系统可能会对相同的错误报出错误代码25。 使用
    <code class="classname">boost::system::error_condition</code>
    ，总是对这个错误报出错误代码12。</p>
<p>最后 Boost.System 提供了类
    <code class="exceptionname">boost::system::system_error</code> ，它派生于
    <code class="exceptionname">std::runtime_error</code>。 它可被用来传送发生在异常里类型为
    <code class="classname">boost::system::error_code</code> 的错误代码。</p>
<pre class="programlisting">#include &lt;boost/asio.hpp&gt; 
#include &lt;boost/system/system_error.hpp&gt; 
#include &lt;iostream&gt; 

int main() 
{ 
  try 
  { 
    std::cout &lt;&lt; boost::asio::ip::host_name() &lt;&lt; std::endl; 
  } 
  catch (boost::system::system_error &amp;e) 
  { 
    boost::system::error_code ec = e.code(); 
    std::cerr &lt;&lt; ec.value() &lt;&lt; std::endl; 
    std::cerr &lt;&lt; ec.category().name() &lt;&lt; std::endl; 
  } 
} </pre>
<ul class="programlisting"><li><a class="programlisting" href="http://zh.highscore.de/cpp/boost/src/15.2.5/main.cpp">下载源代码</a></li></ul>
<p>独立的函数 <code class="function">boost::asio::ip::host_name()</code>
    是以两种方式提供的：一种是需要类型为 <code class="classname">boost::system::error_code</code>
    的参数，另一种不需要参数。 第二个版本将在错误发生时抛出
    <code class="exceptionname">boost::system::system_error</code> 类型的异常。 异常传出类型为
    <code class="classname">boost::system::error_code</code> 的相应错误代码。</p>
</div>
<hr>
<h2 class="title">
<a name="errorhandling_exception"></a>15.3.&nbsp;Boost.Exception</h2>
<div class="sect1">
<p><a class="link" href="http://www.boost.org/libs/exception/">Boost.Exception</a>
    库提供了一个新的异常类 <code class="exceptionname">boost::exception</code>
    允许给一个抛出的异常添加信息。 它被定义在文件 <code class="filename">boost/exception/exception.hpp</code> 中。 由于
    Boost.Exception 中的类和函数分布在不同的头文件中， 下面的例子中将使用 <code class="filename">boost/exception/all.hpp</code> 以避免一个一个添加头文件。</p>
<pre class="programlisting">#include &lt;boost/exception/all.hpp&gt; 
#include &lt;boost/lexical_cast.hpp&gt; 
#include &lt;boost/shared_array.hpp&gt; 
#include &lt;exception&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

typedef boost::error_info&lt;struct tag_errmsg, std::string&gt; errmsg_info; 

class allocation_failed : 
  public boost::exception, 
  public std::exception 
{ 
public: 
  allocation_failed(std::size_t size) 
    : what_("allocation of " + boost::lexical_cast&lt;std::string&gt;(size) + " bytes failed") 
  { 
  } 

  virtual const char *what() const throw() 
  { 
    return what_.c_str(); 
  } 

private: 
  std::string what_; 
}; 

boost::shared_array&lt;char&gt; allocate(std::size_t size) 
{ 
  if (size &gt; 1000) 
    throw allocation_failed(size); 
  return boost::shared_array&lt;char&gt;(new char[size]); 
} 

void save_configuration_data() 
{ 
  try 
  { 
    boost::shared_array&lt;char&gt; a = allocate(2000); 
    // saving configuration data ... 
  } 
  catch (boost::exception &amp;e) 
  { 
    e &lt;&lt; errmsg_info("saving configuration data failed"); 
    throw; 
  } 
} 

int main() 
{ 
  try 
  { 
    save_configuration_data(); 
  } 
  catch (boost::exception &amp;e) 
  { 
    std::cerr &lt;&lt; boost::diagnostic_information(e); 
  } 
} </pre>
<ul class="programlisting"><li><a class="programlisting" href="http://zh.highscore.de/cpp/boost/src/15.3.1/main.cpp">下载源代码</a></li></ul>
<p>这个例子在 <code class="function">main()</code> 中调用了一个函数
    <code class="function">save_configuration_data()</code> ，它调回了
    <code class="function">allocate()</code> 。 <code class="function">allocate()</code>
    函数动态分配内存，而它检查是否超过某个限度。 这个限度在本例中被设定为1,000个字节。</p>
<p>如果 <code class="function">allocate()</code> 被调用的值大于1,000，将会抛出
    <code class="function">save_configuration_data()</code> 函数里的相应异常。
    正如注释中所标识的那样，这个函数把配置数据被存储在动态分配的内存中。</p>
<p>事实上，这个例子的目的是通过抛出异常以示范 Boost.Exception。 这个通过
    <code class="function">allocate()</code> 抛出的异常是
    <code class="exceptionname">allocation_failed</code> 类型的，而且它同时继承了
    <code class="exceptionname">boost::exception</code> 和
    <code class="exceptionname">std::exception</code>。</p>
<p>当然，也不是一定要派生于 <code class="exceptionname">std::exception</code> 异常的。
    为了把它嵌入到现有的框架中，异常 <code class="exceptionname">allocation_failed</code>
    可以派生于其他类的层次结构。 当通过C++标准来定义以上例子的类层次结构的时候， 单独从
    <code class="exceptionname">boost::exception</code> 中派生出
    <code class="exceptionname">allocation_failed</code> 就足够了。</p>
<p>当抛出 <code class="exceptionname">allocation_failed</code>
    类型的异常的时候，分配内存的大小是存储在异常中的，以缓解相应应用程序的调试。 如果想通过 <code class="function">allocate()</code>
    分配获取更多的内存空间，那么可以很容易发现导致异常的根本原因。</p>
<p>如果仅仅通过一个函数(例子中的函数 <code class="function">save_configuration_data()</code>)来调用
    <code class="function">allocate()</code> ，这个信息足以找到问题的所在。 然而，在有许多函数调用
    <code class="function">allocate()</code> 以动态分配内存的更加复杂的应用程序中，这个信息不足以高效的调试应用程序。
    在这些情况下，它最好能有助于找到哪个函数试图分配 <code class="function">allocate()</code> 所能提供空间之外的内存。
    向异常中添加更多的信息，在这些情况下，将非常有助于进程的调试。</p>
<p>有挑战性的是，函数 <code class="function">allocate()</code>
    中并没有调用者名等信息，以把它加入到相关的异常中。</p>
<p>Boost.Exception 提供了如下的解决方案：对于任何一个可以添加到异常中的信息，可以通过定义一个派生于
    <code class="classname">boost::error_info</code> 的数据类型，来随时向这个异常添加信息。</p>
<p><code class="classname">boost::error_info</code>
    是一个需要两个参数的模板，第一个参数叫做标签(tag)，特定用来识别新建的数据类型。 通常是一个有特定名字的结构体。
    第二个参数是与存储于异常中的数据类型信息相关的。</p>
<p>这个应用程序定义了一个新的数据类型 <code class="type">errmsg_info</code>，可以通过
    <code class="classname">tag_errmsg</code> 结构来特异性的识别，它存储着一个
    <code class="classname">std::string</code> 类型的字符串。</p>
<p>在 <code class="function">save_configuration_data()</code> 的 <code class="code">catch</code>
    句柄中，通过获取 <code class="type">tag_errmsg</code> 以创建一个对象，它通过字符串 "saving configuration data
    failed" 进行初始化，以便通过 <code class="methodname">operator&lt;&lt;()</code> 操作符向异常
    <code class="classname">boost::exception</code> 中加入更多信息。 然后这个异常被相应的重新抛出。</p>
<p>现在，这个异常不仅包含有需要动态分配的内存大小，而且对于错误的描述被填入到
    <code class="function">save_configuration_data()</code> 函数中。
    在调试时，这个描述显然很有帮助，因为可以很容易明白哪个函数试图分配更多的内存。</p>
<p>为了从一个异常中获取所有可用信息，可以像例子中那样在 <code class="function">main()</code> 的
    <code class="code">catch</code> 句柄中使用函数
    <code class="function">boost::diagnostic_information()</code> 。 对于每个异常，函数
    <code class="function">boost::diagnostic_information()</code> 不仅调用
    <code class="methodname">what()</code> 而且获取所有附加信息存储到异常中。 返回一个可以在标准输出中写入的
    <code class="classname">std::string</code> 字符串。</p>
<p>以上程序通过Visual C++ 2008编译会显示如下的信息：</p>
<pre class="screen">Throw in function (unknown)
Dynamic exception type: class allocation_failed
std::exception::what: allocation of 2000 bytes failed
[struct tag_errmsg *] = saving configuration data failed</pre>
<p>正如我们所看见的，数据包含了异常的数据类型，通过 <code class="methodname">what()</code>
    方法获取到错误信息，以及包括相应结构体名的描述。</p>
<p><code class="function">boost::diagnostic_information()</code>
    函数在运行时检查一个给定的异常是否派生于 <code class="exceptionname">std::exception</code>。 只会在派生于
    <code class="exceptionname">std::exception</code> 的条件下调用
    <code class="methodname">what()</code> 方法。</p>
<p>抛出异常类型 <code class="exceptionname">allocation_failed</code>
    的函数名会被指定为"unknown"(未知)信息。</p>
<p>Boost.Exception 提供了一个用以抛出异常的宏，它包含了函数名，以及如文件名、行数的附加信息。</p>
<pre class="programlisting">#include &lt;boost/exception/all.hpp&gt; 
#include &lt;boost/lexical_cast.hpp&gt; 
#include &lt;boost/shared_array.hpp&gt; 
#include &lt;exception&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

typedef boost::error_info&lt;struct tag_errmsg, std::string&gt; errmsg_info; 

class allocation_failed : 
  public std::exception 
{ 
public: 
  allocation_failed(std::size_t size) 
    : what_("allocation of " + boost::lexical_cast&lt;std::string&gt;(size) + " bytes failed") 
  { 
  } 

  virtual const char *what() const throw() 
  { 
    return what_.c_str(); 
  } 

private: 
  std::string what_; 
}; 

boost::shared_array&lt;char&gt; allocate(std::size_t size) 
{ 
  if (size &gt; 1000) 
    BOOST_THROW_EXCEPTION(allocation_failed(size)); 
  return boost::shared_array&lt;char&gt;(new char[size]); 
} 

void save_configuration_data() 
{ 
  try 
  { 
    boost::shared_array&lt;char&gt; a = allocate(2000); 
    // saving configuration data ... 
  } 
  catch (boost::exception &amp;e) 
  { 
    e &lt;&lt; errmsg_info("saving configuration data failed"); 
    throw; 
  } 
} 

int main() 
{ 
  try 
  { 
    save_configuration_data(); 
  } 
  catch (boost::exception &amp;e) 
  { 
    std::cerr &lt;&lt; boost::diagnostic_information(e); 
  } 
} </pre>
<ul class="programlisting"><li><a class="programlisting" href="http://zh.highscore.de/cpp/boost/src/15.3.2/main.cpp">下载源代码</a></li></ul>
<p>通过使用宏 <code class="code">BOOST_THROW_EXCEPTION</code> 替代 <code class="code">throw</code>，
    如函数名、文件名、行数之类的附加信息将自动被添加到异常中。但这仅仅在编译器支持宏的情况下有效。 当通过C++标准定义
    <code class="code">__FILE__</code> 和 <code class="code">__LINE__</code> 之类的宏时，没有用于返回当前函数名的标准化的宏。
    由于许多编译器制造商提供这样的宏， <code class="code">BOOST_THROW_EXCEPTION</code> 试图识别当前编译器，从而利用相对应的宏。
    使用 Visual C++ 2008 编译时，以上应用程序显示以下信息：</p>
<pre class="screen">.\main.cpp(31): Throw in function class boost::shared_array&lt;char&gt; __cdecl allocate(unsigned int)
Dynamic exception type: class boost::exception_detail::clone_impl&lt;struct boost::exception_detail::error_info_injector&lt;class allocation_failed&gt; &gt;
std::exception::what: allocation of 2000 bytes failed
[struct tag_errmsg *] = saving configuration data failed</pre>
<p>即使 <code class="exceptionname">allocation_failed</code> 类不再派生于
    <code class="exceptionname">boost::exception</code> 代码的编译也不会产生错误。
    <code class="code">BOOST_THROW_EXCEPTION</code> 获取到一个能够动态识别是否派生于
    <code class="exceptionname">boost::exception</code> 的函数
    <code class="function">boost::enable_error_info()</code>。 如果不是，他将自动建立一个派生于特定类和
    <code class="exceptionname">boost::exception</code> 的新异常类型。
    这个机制使得以上信息中不仅仅显示内存分配异常 <code class="exceptionname">allocation_failed</code>
    。</p>
<p>最后，这个部分包含了一个例子，它选择性的获取了添加到异常中的信息。</p>
<pre class="programlisting">#include &lt;boost/exception/all.hpp&gt; 
#include &lt;boost/lexical_cast.hpp&gt; 
#include &lt;boost/shared_array.hpp&gt; 
#include &lt;exception&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

typedef boost::error_info&lt;struct tag_errmsg, std::string&gt; errmsg_info; 

class allocation_failed : 
  public std::exception 
{ 
public: 
  allocation_failed(std::size_t size) 
    : what_("allocation of " + boost::lexical_cast&lt;std::string&gt;(size) + " bytes failed") 
  { 
  } 

  virtual const char *what() const throw() 
  { 
    return what_.c_str(); 
  } 

private: 
  std::string what_; 
}; 

boost::shared_array&lt;char&gt; allocate(std::size_t size) 
{ 
  if (size &gt; 1000) 
    BOOST_THROW_EXCEPTION(allocation_failed(size)); 
  return boost::shared_array&lt;char&gt;(new char[size]); 
} 

void save_configuration_data() 
{ 
  try 
  { 
    boost::shared_array&lt;char&gt; a = allocate(2000); 
    // saving configuration data ... 
  } 
  catch (boost::exception &amp;e) 
  { 
    e &lt;&lt; errmsg_info("saving configuration data failed"); 
    throw; 
  } 
} 

int main() 
{ 
  try 
  { 
    save_configuration_data(); 
  } 
  catch (boost::exception &amp;e) 
  { 
    std::cerr &lt;&lt; *boost::get_error_info&lt;errmsg_info&gt;(e); 
  } 
} </pre>
<ul class="programlisting"><li><a class="programlisting" href="http://zh.highscore.de/cpp/boost/src/15.3.3/main.cpp">下载源代码</a></li></ul>
<p>这个例子并没有使用函数 <code class="function">boost::diagnostic_information()</code> 而是使用
    <code class="function">boost::get_error_info()</code> 函数来直接获取错误信息的类型
    <code class="classname">errmsg_info</code>。 函数
    <code class="function">boost::get_error_info()</code> 用于返回
    <code class="classname">boost::shared_ptr</code> 类型的智能指针。 如果传递的参数不是
    <code class="exceptionname">boost::exception</code> 类型的，返回的值将是相应的空指针。 如果
    <code class="code">BOOST_THROW_EXCEPTION</code> 宏总是被用来抛出异常，派生于
    <code class="exceptionname">boost::exception</code>
    的异常是可以得到保障的——在这些情况下没有必要去检查返回的智能指针是否为空。</p>
</div>
</div>
<hr class="hrfoot">
<p class="copyright">版权 © 2008-2010 
        <a class="link" href="mailto:boris@highscore.de">Boris Schäling</a>
      </p>


</body></html>